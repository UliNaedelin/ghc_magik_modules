#% text_encoding = iso8859_1
_package sw
#
# GIT HydroS Consult GmbH, Freiburg i. Br.
##
## Objektklasse     : git_mapping
##
## Beschreibung     :
##
## Vererbung        :
##
## Slots            :
##
## Autor            : Jan Kiefer
##
## Datum            : 25.09.2002
##
def_slotted_exemplar( :git_mapping,
		      {
			      {:dsview,_unset,:writable},
			      {:pcounter,_unset,:writable}

		      },
		      {:user_ds_record,
		       :ghc_message_mixin,
		       :ghc_xml_record_mixin})
$

# This option is not available from GUI
git_mapping.define_shared_variable(
	:ghc_select_record_via_non_key_fields?,
	_false,
	:public)
$

git_mapping.define_shared_variable(
	:ghc_select_record_via_field_vec,
	{}, # Vector with internal fieldnames, needs to be manually set
	:public)
$

git_mapping.define_shared_variable(
	:ghc_all_records_accessed_by_fieldvalue_prop,
	hash_table.new(),
	:public)
$

_method git_mapping.fill_all_records_accessed_by_fieldvalue_prop(p_collection)
	##
	_self.ghc_all_records_accessed_by_fieldvalue_prop << hash_table.new()

	_for i_rec _over p_collection.fast_elements()
	_loop
		l_final_value << ""
		_for i_field_name _over _self.ghc_select_record_via_field_vec.fast_elements()
		_loop
			l_value << i_rec.perform(i_field_name)
			_if l_final_value = ""
			_then
				l_final_value << write_string(l_value)
			_else
				l_final_value +<< "_" + write_string(l_value)
			_endif
		_endloop
		_self.ghc_all_records_accessed_by_fieldvalue_prop[l_final_value.as_symbol()] << i_rec
	_endloop
_endmethod
$
_method git_mapping.read_record_with_mapping(rec, _optional ht)
	##
	## liest record mit dem mapping aus entsprechend der
	## mappingstruktur ...
	##
	## Method called for DCC-Exports
	##
	_if ht _is _unset
	_then
		ht << hash_table.new()
	_endif

	_if rec.source_collection.name ~= _self.database_classname
	_then
		#condition.raise(:error,:string,"wrong class")
		#_leave
		_return ht
	_endif

	# Lese erst eigene Feldwerte
	_for fm _over _self.git_field_mappings.fast_elements()
	_loop
		_local fieldkey << fm.external_fieldname.as_symbol()
		_if ht.keys.includes?(fieldkey)
		_then
			condition.raise(:error,:string,_self.message(:duplicate_keys))
		_else
			l_field_name << fm.internal_fieldname.as_symbol()
			_if _not rec.responds_to?(l_field_name)
			_then
				condition.raise(:information,
						:object,
						fm,
						:info_type,
						_self.message(:field_name_does_not_exist).as_symbol(),
						:pm_object_text_info,
						_self.message(:field_name_does_not_exist_detail,
							      rec.source_collection.external_name,
							      fm.internal_fieldname
						      ),
						:check_object_already_protocolled?,
						_true
					  )
				_continue

			_endif
			# hole den wert
			l_value << rec.perform(l_field_name )
			l_conv_value << _self.get_external_conversion_value(l_value,
									    fm,
									    rec)
			_if l_conv_value _isnt _unset
			_then
				l_value << l_conv_value
			_endif

			ht[fieldkey] << l_value
		_endif

		# Baustelle, evtl noch konvertieren ...
		# :conversion_method 	unset
		# :fieldname_conversion? 	unset
		# :reconversion_method 	unset
	_endloop

	# Schaue nach kind Mappings
	_if _self.childs_to_read _isnt _unset _andif
	    (_not _self.childs_to_read.empty?)
	_then
		# Loop über Kind-Mappings
		_for childmap _over _self.childs_to_read.elements()
		_loop
			# finde join_field für das kindmapping
			childfieldname << _self.get_joinfieldname_for_child(rec.source_collection.record_exemplar, childmap.database_classname.as_symbol())
			_if childfieldname _isnt _unset
			_then
				childrec << rec.perform(childfieldname)
				_if childrec.responds_to?(:empty?) _orif
				    childrec _is _unset
				_then
					# write("NOT SUPPORTED CHILD :", childfieldname," Record:", childrec)
				_else
					ht << childmap.read_record_with_mapping(childrec, ht)
				_endif
			_endif
		_endloop
	_endif
	_return ht
_endmethod
$

_method git_mapping.get_gis_fields(_optional ht, p_order_vec)
	##
	## liefert gis fields für die externen feldnamen für die analyse
	## des feldtyps beim export
	##
	## liefert ht[extfieldname] << internal_gis_field

	# initialisiere das hash table mit ext_feldname, int_feldname, intfeldtyp
	_if ht _is _unset
	_then
		ht << hash_table.new()
	_endif

	# suche collection von der database_classname
	# the descriptor <<
	_local views
	_try
		views <<  gis_program_manager.home_datasets_for_collection_name(write_string(_self.database_classname))
		_if views.empty?
		_then
			_local l_text << _self.message(:collection_not_found,

						       _self.database_classname)
			condition.raise(:user_error,:string,l_text)
		_endif
	_when error
	       write("Error col not found ")
	      _return ht
	_endtry
	# Order of field in result-file should be the same as field where created
	_if p_order_vec _is _unset
	_then
		p_order_vec << rope.new()
	_endif
	_for my_view _over views.elements()
	_loop
		my_coll	<< my_view.collections[_self.database_classname.as_symbol()]
		a_desc << my_coll.descriptor

		# Lese erst eigene Feldwerte
		_for fm _over _self.git_field_mappings.elements()
		_loop
			_local fieldkey << fm.external_fieldname.as_symbol()

			_if a_desc.all_fields[fm.internal_fieldname.as_symbol()] _is _unset
			_then
				 condition.raise(:warning,:string,
						 _self.message(:error_internal_field_for_mapping_not_found,
							       fm))
			_else
				p_order_vec.add(fieldkey)
				ht[fieldkey] << a_desc.all_fields[fm.internal_fieldname.as_symbol()]
			_endif
		_endloop
	_endloop

	# Schaue nach kind Mappings
	_if _self.childs_to_read _isnt _unset _andif
	    (_not _self.childs_to_read.empty?)
	_then
		# Loop über Kind-Mappings
		_for childmap _over _self.childs_to_read.elements()
		_loop
			(ht, p_order_vec) << childmap.get_gis_fields(ht, p_order_vec)
		_endloop
	_endif

	_return ht, p_order_vec
_endmethod
$

_method git_mapping.the_geom_field
	##
	## Liefert das erste Geometriefeld des Mappings zurück
	##
	_local gfs << _self.geofields
	_if gfs.size > 1
	_then
		_local l_text << _self.message(:more_than_one_geom_field)
		condition.raise(:warning,:string, l_text)
	_endif

	_if _not gfs.empty?
	_then
		_return gfs.an_element()
	_endif

	_return _unset

_endmethod
$

_method git_mapping.get_joinfieldname_for_child(recex, childname)
	##
	## suche join field
	##
	# Bestimme Joinfeldnamen zur Objektklasse des childmappings
	# Record ist ein Datensatz

	# Hole Record_exemplar
	# changed 281102 jetzt recordexemplar
	# recex << rec.source_collection.record_exemplar

	# Loope über Join fields und suche den Join zum Kind
	_for jf _over recex.join_fields.elements()
	_loop

		# Gefunden wenn target_collection.name = childname !
		_if (tc << jf.ghc!target_collection) _isnt :error
		_then
			_if tc.name = childname
			_then
				# liefere feldnamen zurück
				_return jf.name
			_endif
		_endif
	_endloop

_endmethod
$

_pragma(classify_level=restricted)
_method git_mapping.list_mapping_structure(_optional level)
	##
	## Return a string for printing, etc.
	##
	output << rope.new()
	outobjects << rope.new()

	# Generate the shown string
	output.add_last(_self.message(:class, level,  _self.database_classname))
	outobjects.add_last( _self)

	_for field _over _self.git_field_mappings.elements()
	_loop
		output.add_last(write_string(%space,_self.message(:fieldmap,
					      field.internal_fieldname, field.external_fieldname)))
		outobjects.add_last(field)
	_endloop

	_for submap _over _self.childs_to_read.elements()
	_loop
		# get submappings with tab in front
		(suboutput, subobjects) << submap.list_mapping_structure( level + 1 )
		_for i _over suboutput.elements()
		_loop
			output.add_last(write_string( tab_char, i ))
		_endloop
		outobjects.add_all_last(subobjects)
	_endloop

	_return output, outobjects
_endmethod
$

_method git_mapping.return_submapping(classname)
	##
	## Return a string for printing, etc.
	##
	_local map
	_if _self.database_classname.as_symbol() = classname.as_symbol()
	_then
		_return _self
	_else
		_for child _over _self.childs_to_read.elements()
		_loop
			_if (map << child.return_submapping(classname)) _isnt _unset
			_then
				_return map
			_endif
		_endloop
	_endif

	_return map
_endmethod
$

#_method git_mapping.replace_external_fieldname(l_old_value, l_new_value)
#
##	show(ext_name)
#	ext_name << write_string(ext_name)
#	_for field _over _self.git_field_mappings.fast_elements()
#	_loop
#		_if field.external_fieldname = l_old_value
#		_then
#			field.external_fieldname << l_new_value
#			_return
#		_endif
#
#	_endloop
#
#_endmethod
#$

_method git_mapping.all_subext_names
	##
	##  Load the slot contents of self to the memory_mapping
	##
	_local names << rope.new()
	_local l_field_mapping_vec << rope.new()
	# If field_mappings isnt empty then
	_if _not _self.git_field_mappings.empty?
	_then
		_for fm _over _self.git_field_mappings.elements()
		_loop
			names.add_last( fm.external_fieldname.as_symbol() )
			l_field_mapping_vec.add_last(fm)
		_endloop
	_endif

	_if _not _self.childs_to_read.empty?
	_then
		_for child _over _self.childs_to_read.elements()
		_loop
			(l_child_name_vec, l_child_field_vec) << child.all_subext_names
			names.add_all_last(l_child_name_vec)
			l_field_mapping_vec.add_all_last(l_child_field_vec)
		_endloop
	_endif

	_return names, l_field_mapping_vec

_endmethod
$

_method git_mapping.geofields
	##
	##  Liefert die Geometriefelder sdes mappingsund des submappings
	##
	_local geomfields << rope.new()

	_local type
	# If field_mappings isnt empty then
	_if _not _self.git_field_mappings.empty?
	_then
		_try
			_local fields << keyed_set.new()
			dbcn << write_string(_self.database_classname).as_symbol()
			_local classviews << gis_program_manager.home_datasets_for_collection_name(write_string( dbcn))
			_for av _over classviews.elements()
			_loop
				fields.add_all( av.collections[dbcn].all_fields )
			_endloop

			_for fm _over _self.git_field_mappings.elements()
			_loop
				_if(  type << fields[fm.internal_fieldname.as_symbol()].class_name) _is :dd_geom_field
				_then
					geomfields.add_last({ fm.internal_fieldname.as_symbol(), _self.database_classname.as_symbol()})
				_endif
			_endloop
		_when error
		      show("fehler")
		_endtry
	_endif

	_if _not _self.childs_to_read.empty?
	_then
		_for child _over _self.childs_to_read.elements()
		_loop
			geomfields.add_all_last( child.geofields)
		_endloop
	_endif

	_return geomfields
_endmethod
$

_method git_mapping.number_geofields
	##
	_return _self.geofields.size
_endmethod
$

_method git_mapping.number_geofields_in_tree
	##
	##  Load the slot contents of self to the memory_mapping
	##
	_if (parent << _self.parent_of_childs) _is _unset
	_then
		_return _self.number_geofields
	_else
		_return parent.number_geofields_in_tree + _self.number_geofields
	_endif
_endmethod
$

# OLD:
#
#_method git_mapping.message(name,_optional default,_gather args)
#	## Translates the message NAME into a text string using the
#	## defined message_accessor.
#	##
#	## DEFAULT is the default text string to use if the message
#	## NAME is not found.
#	##
#	## ARGS are the arguments for substitution into the message
#	## string.
#	>> message_handler.new(:ghc_dcc_dm_functionality).human_string(name,default,_scatter args)
#_endmethod
#$
#
# END

_method git_mapping.level
	##
	## Liefert Anzahl von Parents
	##
	_local result
	_if _self.parent_of_childs _is _unset
	_then
		result << 1
	_else
		result << _self.parent_of_childs.level + 1
	_endif

	_return result
_endmethod
$

_method git_mapping.parent_classname
	##
	## Liefert Anzahl von Parents
	##
	_if _self.parent_of_childs _is _unset
	_then
		_return ""
	_else
		_return _self.parent_of_childs.database_classname
	_endif

_endmethod
$

#_method git_mapping.give_field_value_from_rec(rec, fieldname)
#	##
#	## Sucht das Mapping nach dem feld fieldname ab und gibt den
#	## wert des datensatzes zurück
#	## zum auslesen von geometrien, nicht direkt auf dem record...
#	##
#	_local fieldvalue
#	_if rec.responds_to?(fieldname) _andif
#	    _self.own_mapped_fields.includes?(fieldname)
#	_then
#		_return ( fieldvalue << rec.perform(fieldname) )
#	_elif _self.childs_to_read _isnt _unset _andif
#	    (_not _self.childs_to_read.empty?)
#	_then
#		# Schaue nach kind Mappings
#		# Loop über Kind-Mappings
#		# _local return_value
#		_for childmap _over _self.childs_to_read.elements()
#		_loop
#			# finde join_field für das kindmapping
#			childfieldname << _self.get_joinfieldname_for_child(rec.source_collection.record_exemplar,
#									    childmap.database_classname.as_symbol())
#			_if childfieldname _isnt _unset
#			_then
#				childrec << rec.perform(childfieldname)
#				_if childrec.responds_to?(:empty?) _orif
#				    childrec _is _unset
#				_then
#					# write("NOT SUPPORTED CHILD :", childfieldname," Record:", childrec)
#				_else
#					_return childmap.give_field_value_from_rec(childrec,fieldname)
#				_endif
#			_endif
#		_endloop
#	_endif
#
#_endmethod
#$
_method git_mapping.give_field_value_from_rec(rec, fieldname)
	##
	## Sucht das Mapping nach dem feld fieldname ab und gibt den
	## wert des datensatzes zurück
	## zum auslesen von geometrien, nicht direkt auf dem record...
	##
	_local fieldvalue
	_if rec.responds_to?(fieldname) _andif
	    _self.own_mapped_fields.includes?(fieldname)
	_then
		_return ( fieldvalue << rec.perform(fieldname) )
	_elif _self.childs_to_read _isnt _unset _andif
	    (_not _self.childs_to_read.empty?)
	_then
		# Schaue nach kind Mappings
		# Loop über Kind-Mappings
		_local return_value << _unset
		_for childmap _over _self.childs_to_read.elements()
		_loop @cmloop
			# finde join_field für das kindmapping
			childfieldname << _self.get_joinfieldname_for_child(rec.source_collection.record_exemplar,
									    childmap.database_classname.as_symbol())
			_if childfieldname _isnt _unset
			_then
				childrec << rec.perform(childfieldname)
				_if childrec.responds_to?(:empty?) _orif
				    childrec _is _unset
				_then
					# write("NOT SUPPORTED CHILD :", childfieldname," Record:", childrec)
				_else
					_if (return_value << childmap.give_field_value_from_rec(childrec,fieldname)) _isnt _unset
					_then
						# gesuchter wert gefunden, loop kann beendet werden...
						_leave @cmloop
					_endif
				_endif
			_endif
		_endloop

		_return return_value
	_else
		_return _unset
	_endif
_endmethod
$

_method git_mapping.own_mapped_fields
	##
	## liefert rope der internen feldnamen der feldmappings
	##
	_local names << rope.new()
	_for fd _over _self.git_field_mappings.elements()
	_loop
		names.add_last(fd.internal_fieldname.as_symbol())
	_endloop
	_return names
_endmethod
$

_method git_mapping.complete_for_import?
	##
	## Mapping Prüft, ob alle für einen Import notwendigen Felder
	## gemappt sind, d.h.
	##
	## a) Pflichtfelder
	## b) Schlüsselfelder
	##
	## liefert true zurück, wenn alle Bedingungen erfüllt sind,
	## false wenn nicht, Maybe, wenn beim Mapping selbst alle
	## erfüllt sind aber bei den submappings nicht!

	_local submaps << _self.childs_to_read
	_local fmaps << _self.git_field_mappings
	_local classname << _self.database_classname
	_local view
#	_try
	view << gis_program_manager.ghc!find_unique_view_for_table(write_string(classname))
	_if view _is _unset
	_then
	      # nimm irgendeinen view !
	      view << gis_program_manager.ghc!home_datasets_for_collection_name(write_string(classname)).an_element()
	_endif

	# Schaue, ob einem selbst nichts fehlt...
	_local table << view.collections[classname.as_symbol()]
	_local desc << table.descriptor

	# analysiere nun descriptor nach feldern, die pflichtfelder sind...
	_local re << table.record_exemplar
	_local pflichtfelder, mandatory_child_classes

	(pflichtfelder, mandatory_child_classes) << _self.bestimme_pflichtfelder(re)
	# Schaue welche felder gemappt sind....
	_local fdmaps_ok? << _true
	gemappte_feldnamen << sorted_set.new()
	_for mapped_fd _over fmaps.elements()
	_loop
		gemappte_feldnamen.add(write_string(mapped_fd.internal_fieldname).as_symbol())
	_endloop

	# Schaue nun, ob alle Pflichtfelder im Mapping enthalten
	# sind...
	_local notwendige_gemappt? << _true
	_for pf _over pflichtfelder.elements()
	_loop @checker
		_if _not gemappte_feldnamen.includes?(pf)
		_then

			notwendige_gemappt? << _false
			_leave @checker
		_endif
	_endloop
	schluesselfelder_gemappt? << _true
	_for key _over _self.bestimme_schluesselfelder(re).fast_elements()
	_loop
		_if _not (gemappte_feldnamen.includes?(key))
		_then
			schluesselfelder_gemappt? << _false
			_leave
		_endif
	_endloop
	# Schaue nun, ob alle notwendigen kinder gemappt sind.
	_local notwendige_kinder_gefunden?<< _true
	_for ch _over mandatory_child_classes.elements()
	_loop
		_if submaps.select(predicate.eq(:database_classname, write_string(ch))).empty?
		_then
			notwendige_kinder_gefunden?<< _false
		_endif
	_endloop

	# Frage nun die Kinder, ob sie alles haben was sie brauchen...
	_local kinder_ok? << _true
	_if _not submaps.empty?
	_then
		_for child _over submaps.elements()
		_loop @checke_kinder
			_local child_ok? << child.complete_for_import?
			_if child_ok? _is _false
			_then
				kinder_ok? << _false
				_leave @checke_kinder
			_endif
		_endloop
	_endif

	# show(notwendige_gemappt?)
	# show(kinder_ok?)
	# show(notwendige_kinder_gefunden?)

	_local info << sorted_set.new()

	_if schluesselfelder_gemappt? _is _true
	_then
		info.add(:update_moeglich)
	_endif

	_if notwendige_gemappt? _is _true
	_then
		info.add(:insert_moeglich)
	_endif

	_if (_not notwendige_gemappt?) _orif
	    (_not schluesselfelder_gemappt?)
	_then
		info.add(:pflichtfelder_nicht_gemappt)
	_endif

	_if _not kinder_ok?
	_then
		info.add(:kinder_nicht_gesund)
	_endif

	_if _not notwendige_kinder_gefunden?
	_then
		info.add(:nicht_alle_kinder_gefunden)
	_endif

	_if ((notwendige_gemappt? _orif
	      schluesselfelder_gemappt?) _andif
	     kinder_ok? _andif
	     notwendige_kinder_gefunden?)
	_then
		_return (_true, info)
	_elif ((notwendige_gemappt? _orif
		schluesselfelder_gemappt?) _andif
	       ((_not kinder_ok?) _orif (_not notwendige_kinder_gefunden?)))
	_then
		_return (_maybe, info)
	_else
		_return (_false, info)
	_endif
_endmethod
$

_method git_mapping.bestimme_pflichtfelder(re)

	# erst die Pflichtgeometriefelder ...
	_local pflichtfelder << sorted_set.new()
	_if _not (_not re.responds_to?(:editing_properties) _orif
		  (mf << re.editing_properties[:mandatory_fields]) _is _unset )
	_then
		pflichtfelder.add_all(mf)
	_endif

	# finde interne Feldbezeichnungen des Text-Join Felder
	# Die Text felder sollen dann ignoriert werden.
	_local interne_text_jfs << sorted_set.new()
	_for i _over re.join_fields.elements()
	_loop
		_if i.join_type _is :text
		_then
			interne_text_jfs.add(i.parameters[1])
		_endif
	_endloop
	# nun die anderen physikalischen felder (nicht joins)
	# und die schlüsselfelder, wenn nicht automatisch erzeugt
	_for the_fields _over {:physical_fields,
			       :key_fields}.elements()
	_loop
		_for fd _over re.perform(the_fields).elements()
		_loop
			# debug ---
			_if fd.responds_to?(:mandatory?)
			_then
				_if fd.mandatory?
				_then
					# Ignoriere interne Text Join Fields und auch
					# Datenbankversionsstempel und Rwo ids, die vom Gis selbst
					# erzeugt werden.
					_if ( _not interne_text_jfs.includes?(fd.name)) _andif
					    ( _not { :ds_vstamp, :gis_id , :sys_id }.includes?( fd.type.name )) _andif
					    (_not re.join_field_names.includes?(fd.name))
					_then
						# If field has generator, then not necessarily needed in definition
						_if fd.responds_to?(:generator) _andif
						    fd.generator _isnt _unset
						_then
							_continue
						_endif

						#show(fd.name, fd.type, fd.type.name)
						pflichtfelder.add(fd.name)
					_endif

				_endif
			_endif
		_endloop
	_endloop

	 _local mandatory_child_classes << _self.find_mandatory_child_classes(pflichtfelder, re)

	_return (pflichtfelder,  mandatory_child_classes)

_endmethod
$
_method git_mapping.bestimme_schluesselfelder(re)

	# erst die Pflichtgeometriefelder ...
	_local schluesselfelder << set.new()
	_local schluessel_vec << set.new()

	schluessel_vec.add_all(re.key_fields)
	_for schluessel _over schluessel_vec.fast_elements()
	_loop
		schluesselfelder.add(schluessel.name)
	_endloop

	_return schluesselfelder

_endmethod
$

_method git_mapping.find_mandatory_child_classes(pflichtfelder,re)
	##
	## methode fidnet die Objektklafssen, die als Childmappings
	## notwendigerweise gemappt sein müssen, da ein Join mit der
	## eigenen Funktion :super besteht
	##
	_local mandatory_child_classes << rope.new()

	_for f _over re.join_fields.elements()
	_loop
		_if f.join_type _isnt :text
		_then

			_for  i _over f.relation_fields()
			_loop
				_if f.responds_to?(:structure_type) _andif
				    f.responds_to?(:relation_type)
				_then
					_if f.structure_type _is :super _andif
					    f.ghc!relation_type.matches?("*:1")
					_then
						_local the_class << f.ghc!target_collection.name
						# Esentielle Klasse:
						mandatory_child_classes.add_last(the_class)
					_endif
				_endif

			_endloop
		_endif

	_endloop
 #	print( mandatory_child_classes)
	_return mandatory_child_classes
_endmethod
$

_method git_mapping.prepare_for_check_values( records,
					      _optional view
		    )
	##
	## liest record mit dem mapping aus entsprechend der
	## mappingstruktur ...

	# Suche DSview der Collection
	_local tabname << write_string(_self.database_classname)
	_if view _is _unset
	_then
		.dsview << gis_program_manager.ghc!find_unique_view_for_table( tabname )
	_else
		.dsview << view
	_endif

	_local geofield

	_local coll << .dsview.collections[tabname.as_symbol()]

	_self.changed(:action,
		      :write_records_to_db,
		      write_string("[",
				   .dsview.external_name,"] ",
				   coll.external_name))

	#ok? << .dsview.start_lwt()
	recstat << set.new()

	# Suche Geometriefeld
	_try
		geofield << _self.the_geom_field[1].as_symbol()
	_when error
	      # Hinweis daß Import ohne Geometrien erfolgt!
	      _self.changed(:process_status,:importing_without_geometry)
	_endtry

	# eigene gemappte Feldwerte
	_return  _self.get_my_hash_table(geofield), coll
_endmethod
$

_method git_mapping.write_records_to_database( records,
					       process_thread,
					       mode,
					       _optional view ,
					       add_catalogue_values?,
					       default_values,
					       convert_dos_to_ansi?,
					       datenauswertung?
		    )
	##
	## liest record mit dem mapping aus entsprechend der
	## mappingstruktur ...

	mode << mode.as_symbol()
	# Suche DSview der Collection
	_local tabname << write_string(_self.database_classname)
	_if view _is _unset
	_then
		.dsview << gis_program_manager.ghc!find_unique_view_for_table( tabname )
	_else
		.dsview << view
	_endif

	_local geofield

	_local coll << .dsview.collections[tabname.as_symbol()]

	condition.raise(:coll_process_thread,
			:coll_thread,
			process_thread,
			:action,
			:start_writing_data_to_db,
			:method,
			{:|engine_init_progress_window()|, records.size, _self.message(:start_writing_to_db)}
		  )

#	_self.changed(:action,
#		      :write_records_to_db,
#		      write_string("[",
#				   .dsview.external_name,"] ",
#				   coll.external_name))

	recstat << set.new()
	ok? << _false
	_local counter << 0

	# Suche Geometriefeld
	_try
		geofield << _self.the_geom_field[1].as_symbol()
	_when error
		# Hinweis daß Import ohne Geometrien erfolgt!
		_self.changed(:process_status,:importing_without_geometry)
	_endtry

	# eigene gemappte Feldwerte
	_local ht << _self.get_my_hash_table(geofield)

	process_thread.current_line << 0

	_if _self.ghc_select_record_via_non_key_fields? _is _true
	_then
		_self.fill_all_records_accessed_by_fieldvalue_prop(coll)
	_endif

	# hier die eigentlichen Datensätze aktualisieren
	_for rec _over records.elements()
	_loop
		process_thread.pm_check_suspend()

		_if process_thread.commit_changes? _is _true _andif
		    .dsview.updated?
		_then
			.dsview.commit()
		_endif

		counter+<<1
		process_thread.next_record(rec)

		# Datensätze schreiben ...
		_local recok? << .dsview.start_lwt()
		error? << _true
		_protect
			_local newrec, myrecok?
			_catch process_thread.next_record_tag

			       process_thread.current_line +<< 1

			       (newrec, myrecok?)  << _self.write_record(rec, coll,
									 process_thread,
									 ht, mode,
									 geofield,
									 add_catalogue_values?,
									 default_values,
									 convert_dos_to_ansi?,
									 datenauswertung?
							    )
			_endcatch

			_if myrecok? _is :skip
			_then
				_continue
			_endif
			_if myrecok? _is _true
			_then
				recok? << _true
			_endif

		_protection
			_try
				.dsview.end_lwt(recok?)
			_when error
				condition.raise(:coll_process_thread,
						:coll_thread,
						process_thread,
						:action,
						:bad_undo_state,
						:method,
						{:|engine_bad_undo_state()|, process_thread, .dsview}
					  )
			_endtry

		_endprotect
	_endloop
	_if _self.responds_to?(:method_after_map_compl)
	_then
		method_after << _self.perform(:method_after_map_compl)

		_if method_after _isnt _unset
		_then

			method_prop << method_after.ghc!as_method()

			_if method_prop _isnt  _unset _andif
			    method_prop[:method_name] _isnt _unset _andif
			    git_dcc_specific_methods _isnt _unset _andif
			    git_dcc_specific_methods.responds_to?(method_prop[:method_name])
			_then

				_if method_prop[:method_args] _is _unset
				_then
					git_dcc_specific_methods.perform(method_prop[:method_name])
				_else
					git_dcc_specific_methods.perform(method_prop[:method_name], _scatter method_prop[:method_args])
				_endif

			_endif

		_endif
	_endif
	_return ok?, counter
_endmethod
$

# PROGRESS()
_pragma(classify_level=restricted)
_method git_mapping.progress(act,max)
	##
	## liefert den fortschritt in %
	##
	_local value << 0
	_if max ~= 0
	_then
		value << ((act/max)*100).rounded
	_endif
	_self.changed(:progress, value )
_endmethod
$

_method git_mapping.get_my_hash_table(_optional geofield)
	##
	## Liefert hash table der selbst gemappten felder
	##
	_local ht << hash_table.new()
	_for fm _over _self.git_field_mappings.elements()
	_loop

		_local fieldkey << fm.external_fieldname.write_string.lowercase.as_symbol()
		_if ht.keys.includes?(fieldkey)
		_then
			condition.raise(:error,:string,_self.message(:duplicate_keys))
		_else
			# ignoriere geometriefeld
			_if fm.internal_fieldname.as_symbol() _isnt geofield
			_then
				ht[fieldkey] << fm.internal_fieldname.write_string.lowercase.as_symbol() #.with_chevron
			_endif
		_endif
	_endloop

	_return  ht
_endmethod
$
#
# Alte Methode mit TEmplate records ...

_method git_mapping.write_record( rec, coll,
				  process_thread,
				  ht, mode
				  _optional geofield,
				  add_catalogue_values?,
				  default_values,
				  convert_dos_to_ansi?,
				  datenauswertung?
		    )
	##
	## Schreibt einen eingelesenen Record und alle untergeordneten
	## Kindrecords gemäß der definierten Mappingstruktur
	##
	## add_catalogue_values? suspended
	_dynamic !notify_database_data_changes?! << _false
	process_thread.current_obj << _unset

	ergaenzen? <<  {:|Import + best. Objekte ergänzen|,
			:|Pflichtfelder unvollständig! Versuche Import + best. Objekte ergänzen|
		       }.includes?(mode)

	veraendern? << {:|Import + best. Objekte verändern|,
			:|Pflichtfelder unvollständig! Versuche Import + best. Objekte verändern|
		       }.includes?(mode)
	unveraendert? << {:|Import + best. Objekte bleiben unverändert|,
			  :|Pflichtfelder unvollständig! Versuche Import + best. Objekte unverändert|
			 }.includes?(mode)
	aktualisiert_ergaenzen? << {:|Aktualisierungsimport! Objekte ergänzen|}.includes?(mode)
	aktualisiert_veraendern? << {:|Aktualisierungsimport! Objekte verändern|}.includes?(mode)

	aktualisiert? << aktualisiert_ergaenzen? _orif
			 aktualisiert_veraendern?

	default_values << default_values.default(hash_table.new_with(:string, "unbekannt",
								     :number, 0))

	add_catalogue_values? << add_catalogue_values?.default(_false)

	# Get values Property list for transaction
	l_value_prop << property_list.new()
	_for i_external_name, i_internal_name _over ht.keys_and_elements()
	_loop
		l_value_prop[i_internal_name] <<  rec[i_external_name.write_string.lowercase.as_symbol()]

	_endloop

	_if _self.responds_to?(:method_before_insertion)
	_then
		
		method_before << _self.perform(:method_before_insertion)
		_if method_before _isnt _unset
		_then
			method_before << method_before.as_symbol()
			_if coll.record_exemplar.responds_to?(method_before)
			_then
				l_import_rec << coll.record_exemplar.perform(method_before,
									     l_value_prop
								     )		
			_else
				_if method_before.size > 3 _andif
				    (l_value << l_value_prop[(l_field_name << method_before.slice(1, method_before.size -2)).as_symbol()]) _isnt _unset 
				_then
					_if (l_rec << coll.select(predicate.eq(l_field_name, l_value)).an_element()) _isnt _unset 
					_then
						_for i_key_field _over l_rec.key_field_names()
						_loop
							l_value_prop[i_key_field] << l_rec.perform(i_key_field)
						_endloop
						searched_rec << l_rec
					_endif
					
				_endif
				
			_endif
		_endif
	_endif
	
	# Hier wird geprüft, ob die gemappten felder alle
	# schlüsselfelder enthalten... wenn dem so ist, dann muss in
	# der Datenbank der u.U. schon bestehende Datensatz gesucht und
	# entsprechent aktualisiert werden...
	_local record_is_new? << _false
	_local trec
	_local key_fields << rope.new()
	_for kf _over  coll.key_field_names.elements()
	_loop
		key_fields.add_last(kf) #.with_chevron)
	_endloop

	ueberschrieben? << _false
	_if searched_rec _is _unset 
	_then
		(searched_rec, info) << _self.search_object(ht,
							    rec,
							    key_fields,
							    coll,
							    process_thread,
							    aktualisiert?,
							    unveraendert?,
							    datenauswertung?,
							    searched_rec
					      )
	_endif


	# No Insert Option wanted, skip to next record
	_if info _is :skip
	_then
		_return searched_rec, :skip
	_endif

	from_new_detached? << _false

	# Wenn Gesamtimport oder Inkrementeller Import
	_if searched_rec _is _unset
	_then
		# Für Inkrementell und Gesamtimport
		# Schlüsselfelder werden zugeordnet, neuer Record wird erzeugt

		l_import_value_prop << _self.create_value_prop_for_import(l_value_prop,
									  coll,
									  geofield,
									  rec[:git!geometry]
					     )
	

		_if l_import_rec _is _unset
		_then
			_if coll.record_exemplar.is_rwo? _andif
			    coll.record_exemplar.dataless?
			_then

				# Geometry must be first field in property_list
				l_temp_prop << property_list.new()
				l_ordered_prop << property_list.new()
				_for f_name, val  _over l_import_value_prop.keys_and_elements()
				_loop

					l_field << coll.field(f_name)
					_if l_field.is_geometry? _andif
					    val _isnt _unset
					_then

						l_tr << transform.new_converting_cs_to_cs(!current_coordinate_system!,
											  coll.source_view.world.coordinate_system
								  )

						_if _not val.responds_to?(:world)
						_then
							l_tr << transform.new_converting_cs_to_cs(!current_coordinate_system!,
											  coll.source_view.world.coordinate_system
									  )
							l_trans_val << val.transform(l_tr)

							# val is sector_rope
							_if l_field.geom_type _is :area _orif
							    l_field.geom_type _is :simple_area
							_then

								l_geom << pseudo_area.new(l_trans_val)
							_elif l_field.geom_type _is :chain _orif
							      l_field.geom_type _is :simple_chain
							_then
								l_geom << pseudo_chain.new(l_trans_val)
							_else
								l_geom << pseudo_point.new(l_trans_val)
							_endif

							l_geom.world << coll.source_view.world

						_else
							l_geom << val
						_endif

						l_ordered_prop[f_name] << l_geom

					_else

						l_temp_prop[f_name] << val
					_endif

				_endloop
				l_ordered_prop.add_all(l_temp_prop)
				l_import_value_prop << l_ordered_prop
			_endif

			rt << record_transaction.new_insert( coll,
							     l_import_value_prop,
							     _self.message(:dcc_insertion)
						 )

			l_import_rec << rt.run()

		_endif

	_endif

	auswertung_prop << property_list.new()
	_if searched_rec _isnt _unset
	_then

		l_unvalid_field_vec << rope.new()
		# Skip all update values

		l_update_value_prop << _self.create_value_prop_for_import(l_value_prop,
									  coll,
									  geofield,
									  rec[:git!geometry],
									  searched_rec,
									  auswertung_prop,
									  (ergaenzen? _orif
									   aktualisiert_ergaenzen?),
									  (veraendern? _orif
									   aktualisiert_veraendern?)
					     )

		rt << record_transaction.new_update( searched_rec,
						     l_update_value_prop,
						     _self.message(:dcc_update))
		l_import_rec << rt.run()

	_endif

	# Nun noch Löcher in Geometrie erzeugen, falls notwendig
	_if geofield _isnt _unset _andif
	    rec[:git!geometry] _isnt _unset _andif

	    l_import_rec.all_field_names.includes?( geofield) _andif
	    l_import_rec.perform(geofield.as_symbol()) _is _unset
	_then

		_if rec[:git!geometry].class_name _is :rope _andif
		    rec[:git!geometry].size > 0
		_then

			_for hole_area _over rec[:git!geometry].fast_elements()
			_loop
				_if l_import_rec.perform(geofield) _is _unset
				_then
					_continue
				_endif
				_try
					# Try to cut hole out of geometry
					l_import_rec.perform(geofield).add_hole(hole_area)
				_when error
					# if hole_area is not inside main_area, then add it as a new
					# region
					l_import_rec.perform(geofield).union_in_situ(hole_area)
				_endtry
			_endloop

		_else
			# BUG 252: Text_meth Klammern falsch
			_if l_import_rec.source_collection.all_fields[geofield.as_symbol()].responds_to?(:text_method) _andif
			    (text_meth <<  l_import_rec.source_collection.all_fields[geofield.as_symbol()].text_method) _isnt _unset
			_then
				# End BUG
				text << _unset
				_try
					text << l_import_rec.perform(text_meth)
				_when error

				_endtry
				text << text.default("")

				l_import_rec.make_geometry(  geofield.as_symbol(), rec[:git!geometry], text)

			_endif
		_endif

	_endif

	_if searched_rec _isnt _unset
	_then
		_if _not (_self.auswertung_hat_aenderungen?(auswertung_prop))

		_then
			l_info_type << _self.message(:unchanged_records).as_symbol()

		_else
			l_info_type << _self.message(:updated_records).as_symbol()

		_endif
		_if datenauswertung? _is _true
		_then
			auswertung_string << _self.auswertung_als_string(auswertung_prop,
									 searched_rec,
									 l_import_rec)
		_else
			auswertung_string << _unset
		_endif
		condition.raise(:information,
				:object,
				searched_rec,
				:info_type,
				l_info_type,
				:pm_object_text_info,
				auswertung_string
			  )
	_else
		condition.raise(:information,
				:object,
				l_import_rec,
				:info_type,
				_self.message(:new_records).as_symbol()
			  )
	_endif

	# Import verknüpfter Datensätze -> Not supported
#	# Joins herstellen ...
#	_if _not childrecs.empty?
#	_then
#		_for ch_key,ch_rec _over childrecs.keys_and_elements()
#		_loop
#			_local k << ch_key.with_chevron
#			l_import_rec.perform(k, ch_rec)
#		_endloop
#	_endif

#	# Für Textfelder nachbearbeitung
#
#	_if text_feld_vec _isnt _unset
#	_then
#
#		_for i  _over range(1, text_feld_vec.size, 2)
#		_loop
#			l_import_rec.perform(text_feld_vec[i].with_chevron, text_feld_vec[i+1])
#		_endloop
#
#	_endif

	_if _self.responds_to?(:method_after_insertion)
	_then
		method_after << _self.perform(:method_after_insertion)

		_if method_after _isnt _unset
		_then
			method_prop << method_after.ghc!as_method()
			_if method_prop _isnt  _unset _andif
			    method_prop[:method_name] _isnt _unset _andif
			    l_import_rec.responds_to?(method_prop[:method_name])
			_then

				_if method_prop[:method_args] _is _unset
				_then
					l_import_rec.perform(method_prop[:method_name])
				_else
					l_import_rec.perform(method_prop[:method_name], _scatter method_prop[:method_args])
				_endif

			_endif

		_endif
	_endif

	_return (l_import_rec, _true )
_endmethod
$

_pragma(classify_level=restricted)
_method git_mapping.create_value_prop_for_import(p_value_prop,
						 p_coll,
						 p_geofield,
						 p_geo_value,
						 _optional p_searched_rec,
						 auswertung_prop,
						 p_ergaenzen?,
						 p_veraendern?
		    )
	##
	auswertung_prop << auswertung_prop.default(property_list.new())
	l_transaction_value_prop << property_list.new()
	_for i_internal_name, i_value _over p_value_prop.keys_and_elements()
	_loop
		l_new_value << i_value

		# If field does not exist
		_if p_coll.field(i_internal_name) _is _unset
		_then
#			_if _not l_unvalid_field_vec.includes?(i_internal_name)
#			_then
			condition.raise(:information,
					:object,
					_unset,
					:info_type,
					_self.message(:field_name_does_not_exist).as_symbol(),
					:pm_object_text_info,
					_self.message(:field_name_does_not_exist_detail,

						      p_coll.external_name,
						      i_internal_name.write_string
					      )
				  )

#				l_unvalid_field_vec.add(i_internal_name)
#
			_continue

		_endif

		# If searched rec isnt unset, it is an UPDATE
		_if p_searched_rec _isnt _unset
		_then
			l_old_value << p_searched_rec.perform(i_internal_name)

			_self.datenauswertung(auswertung_prop,
					      i_internal_name,
					      l_old_value,
					      l_new_value,
					      p_ergaenzen?,
					      p_veraendern?
#					      (ergaenzen? _orif
#					       aktualisiert_ergaenzen?),
#					      (veraendern? _orif
#					       aktualisiert_veraendern?)
			      )

			# Einfügefeld überspringen, wenn bestehende Objekte lediglich
			# ergänzt werden sollen
			_if p_ergaenzen? _andif
			    p_searched_rec.perform(i_internal_name) _isnt _unset
			_then
				_continue
			_endif

			# Schlüsselfelder werden bei UPDATE übersprungen
			_if p_coll.key_field_names.includes?(i_internal_name)
			_then
				_continue
			_endif
		_endif

		# Transform "unset" in _unset
		_if l_new_value = "unset" _then
			l_new_value << _unset
		_endif

		# Fügt Feldwerte ein.

		# Entferne Leerzeichen vom String und setze falls dieser leer
		# ist unset
		_if l_new_value.inherits_from?(charindex_mixin)
		_then
			l_new_value << write_string( l_new_value.trim_spaces())
			_if l_new_value.size = 0
			_then
				l_new_value << _unset
			_endif
		_endif

		l_transaction_value_prop[i_internal_name] << l_new_value

	_endloop

	# Adding Geometry

	_if p_geofield _isnt _unset _andif
	    p_geo_value _isnt _unset

	_then

		_if p_coll.field(p_geofield.as_symbol()) _is _unset
		_then

			condition.raise(:information,
					:object,
					_unset,
					:info_type,
					_self.message(:field_name_does_not_exist).as_symbol(),
					:pm_object_text_info,
					_self.message(:field_name_does_not_exist_detail,
						      p_coll.external_name,
						      p_geofield.write_string
					      )
				  )

		_else
			_if p_searched_rec _isnt _unset
			_then
				auswertung_prop[:geom_info] << p_geofield

				_if (l_old_geom << p_searched_rec.perform(p_geofield.as_symbol())) _isnt _unset
				_then

					_if p_veraendern?
					_then

						auswertung_prop[:old_geom_info_prop] << property_list.new()
						_if l_old_geom.responds_to?(:area) _andif
						    l_old_geom.area > 0.0
						_then
							auswertung_prop[:old_geom_info_prop][:area] << l_old_geom.area
						_elif l_old_geom.responds_to?(:line_length) _andif
						      l_old_geom.line_length > 0.0
						_then
							auswertung_prop[:old_geom_info_prop][:line_length] << l_old_geom.line_length
						_elif l_old_geom.responds_to?(:|a_coord()|) _andif
						      l_old_geom.a_coord() _isnt _unset
						_then
							auswertung_prop[:old_geom_info_prop][:coordinate] << l_old_geom.a_coord()
						_endif

						p_searched_rec.unset_geometry( p_geofield.as_symbol())
						auswertung_prop[:geom_action] << :replaced

					_else
				#		auswertung_prop[:geom_action] << :untouched

					_endif

				_endif
			_endif

			_if p_searched_rec _is _unset _orif
			    p_searched_rec.perform(p_geofield.as_symbol()) _is _unset
			_then
				_if auswertung_prop[:geom_action] _is _unset
				_then
					auswertung_prop[:geom_action] << :created
				_endif

				### Uli 9.03.04 Behandeln von Löchern in Flächen
				#	 show(p_value_prop[:git!geometry].class_name )
				_if p_geo_value.class_name _is :rope

				_then
					(biggest_area, other_area) << _self.biggest_area(p_geo_value)

					l_transaction_value_prop[p_geofield.as_symbol()] << biggest_area
#					rt << record_transaction.new_update( l_import_rec,
#									     rec,
#									     _self.message(:dcc_update))

#					l_import_rec.make_geometry(  geofield.as_symbol(), biggest_area)
#					_for hole_area _over other_area.fast_elements()
#					_loop
#						l_import_rec.perform(geofield).add_hole(hole_area)
#					_endloop
				_else
				#	write("+++ l_transaction_value_prop[p_geofield.as_symbol()] << p_value_prop[:git!geometry] +++")
				#					l_transaction_value_prop[p_geofield.as_symbol()] << p_geo_value
#					# BUG 252: Text_meth Klammern falsch
					_if p_coll.all_fields[p_geofield.as_symbol()].responds_to?(:text_method) _andif
					    (text_meth <<  p_coll.all_fields[p_geofield.as_symbol()].text_method) _isnt _unset
					_then

						# DO TEXT NOT IN TRANSACTION -->  Not Working (missing text)
						# End BUG
#						text << _unset
#						_try
#							text << p_searched_rec.perform(text_meth)
#						_when error
#
#						_endtry
#						text << text.default("")
#						l_transaction_value_prop[p_geofield.as_symbol()] << p_geo_value

#							property_list.new_with(
#													    :geometry,
#													    p_geo_value,
#													    :text,
#													    text)
#						l_import_rec.make_geometry(  geofield.as_symbol(), rec[:git!geometry], text)

					_else
						l_transaction_value_prop[p_geofield.as_symbol()] << p_geo_value
#						l_import_rec.make_geometry(  geofield.as_symbol(), rec[:git!geometry])
					_endif
				_endif
			_endif

		_endif
	_endif
	_return l_transaction_value_prop
_endmethod
$
_pragma(classify_level=restricted)
_method git_mapping.search_object(ht,
				  rec,
				  key_fields,
				  coll,
				  process_thread,
				  aktualisiert?,
				  unveraendert?,
				  datenauswertung?,
				  searched_rec
		    )
	##
	## Searches for record. If record not exist, evaluate whether
	## to create one and protocol it

	_if _self.ghc_select_record_via_non_key_fields? _isnt _true
	_then
		# Alle Schlüsselfelder vorhanden?
		_if rope.new_from(ht).includes_all?(key_fields) #_andif
		#  rec.keys.includes_all?( key_fields)
		_then
			# in diesem Fall sind alle keyfelder gemappt..
			# suche nun den record
			# Erst die WErte der Keyfelder aus dem Hash table holen
			keyvalues << rope.new(coll.key_field_names.size)
			posit << 0
			_for kf _over coll.key_field_names.fast_elements()
			_loop
				posit +<< 1
				# hier muss der wert gesucht werden
				# get external name for the key field ..
				ext_kf << _self.get_external_fieldname_for_field(kf)
				_local aktueller_keyval <<  rec[ext_kf.write_string.lowercase.as_symbol()]
				_if aktueller_keyval.inherits_from?(charindex_mixin)
				_then
					aktueller_keyval << aktueller_keyval.trim_spaces()
				_endif
				# Für korrekte Reihenfolge der Key-Felder
				keyvalues[coll.key_field_numbers[posit]] << aktueller_keyval
			_endloop
			# nun der Zugriff auf Datensatz
			searched_rec << coll.at(_scatter keyvalues)
		_endif

	_else
		final_wert << ""
		_for i_field_name _over _self.ghc_select_record_via_field_vec.fast_elements()
		_loop

			ext_kf << _self.get_external_fieldname_for_field(i_field_name)

			_local aktueller_val <<  rec[ext_kf.write_string.lowercase.as_symbol()]
			_if aktueller_val.inherits_from?(charindex_mixin)
			_then
				aktueller_val << aktueller_val.trim_spaces()
			_endif
			_if final_wert = ""
			_then
				final_wert << write_string(aktueller_val)
			_else
				final_wert +<< "_" + write_string(aktueller_val)
			_endif

			# To Slow
#			_if l_pred _is _unset
#			_then
#				l_pred << predicate.new(
#						  i_field_name,
#						  :eq,
#						  aktueller_val)
#			_else
#				l_pred << l_pred.predicate_and(predicate.new(
#								       i_field_name,
#								       :eq,
#								       aktueller_val))
#			_endif
		_endloop
		# To slow
#		searched_rec_vec << rope.new_from(
#					    coll.select(l_pred)
#					 )
#
#		_if searched_rec_vec.size > 1
#		_then
#			show(write_string("More than one record found with Predicate: ",
#					  l_pred)
#			)
#		_endif

		keyvalues << _self.get_selected_record_via_field(final_wert)
		_if keyvalues _isnt _unset
		_then
			searched_rec << coll.at(_scatter keyvalues)
		_endif
	_endif

	_if searched_rec _is _unset
	_then
		# Wenn noch kein Datensatz mit den Schlüsselwerten existiert
		_if aktualisiert?
		_then
			_if datenauswertung? _is _true
			_then
				obj << gis_program_manager.ghc!a_home_dataset_for_table(:ghc_process_dummy).collections[:ghc_process_dummy].new_detached_record()

				obj.info << _self.message(:record_number,
							  process_thread.current_line.default("?")
						  )

				info_string << write_string(_self.message(:key_fields),
							    newline_char)
				_for key_field _over coll.key_fields.fast_elements()
				_loop
					ext_kf << _self.get_external_fieldname_for_field(key_field.name)
					aktueller_keyval <<  rec[ext_kf.write_string.lowercase.as_symbol()]
					info_string +<< write_string(key_field.external_name,
								     ": ",
								     aktueller_keyval,
								     newline_char
							)
				_endloop

				# Datensatz überspringen bei update
				condition.raise(:information,
						:object,
						obj,
						:info_type,
						_self.message(:no_record_with_key).as_symbol(),
						:pm_object_text_info,
						info_string
					  )
			_endif

			# Datensatz überspringen bei update
			_return _unset, :skip
		_endif

	_else

		process_thread.current_obj << searched_rec
		# Wenn Datensatz mit Schlüsselwert existiert
		_if unveraendert?
		_then
			condition.raise(:information,
					:object,
					searched_rec,
					:info_type,
					_self.message(:record_exist_no_change).as_symbol()
				  )

			# Wenn Nur neue Objekte erzeugen ausgewählt wurde, Datensatz überspringen
			_return searched_rec, :skip
		_endif

		#			# Wird nicht mehr angeboten da zu gefährlich
		#			_if {:|Gesamtimport: bestehende Objekte überschreiben|,
		#			     :|Pflichtfelder unvollständig. Versuche Gesamtimport|}.includes?(mode)
		#			_then
#				_if _self.has_autogenerated_key_fields?(coll)
#				_then
#					condition.raise(:information,
#							:agr_object,
#							searched_rec,
#							:agr_kategorie,
#							:|Gelöschte Datensätze, da überschrieben|
#						  )
#				_endif
#				ueberschrieben? << _true
#
#				# Wenn Neue Objekte alte überschreiben alten löschen
#				searched_rec.delete()
#
#				searched_rec << _unset
#			_endif
	_endif

#	_else   # Nicht alle Schlüsselfelder vorhanden
#
#		# Wenn noch kein Datensatz mit den Schlüsselwerten existiert
#		_if aktualisiert?
#		_then
#			_return _unset, :skip
#		_endif
#	_endif
	_return searched_rec
_endmethod
$

_pragma(classify_level=restricted)
_method git_mapping.get_selected_record_via_field(p_concated_field_value)
	##
	l_record_prop << _self.ghc_all_records_accessed_by_fieldvalue_prop
	l_rec << l_record_prop[p_concated_field_value.as_symbol()]
	_if l_rec _is _unset
	_then
		show("Für folgenden Ausdruck keinen Datensatz gefunden: ",  p_concated_field_value)
		_return
	_endif
	l_value_vec << rope.new()
	_for i_kf _over l_rec.source_collection.key_field_names.fast_elements()
	_loop
		l_value_vec.add(l_rec.perform(i_kf))
	_endloop
	_return l_value_vec

_endmethod
$

#_pragma(classify_level = basic, topic = {GIT, GIT_BASE, engine})
#_method git_mapping.insert_new_record(ht,
#				      rec,
#				      coll,
#				      process_thread,
#				      childrecs
#		    )
#	##
#	key_fields << _self.get_key_values(ht, rec, coll)
#	needed_fields << _self.get_mandatory_fields(ht, rec, coll)
#	needed_relations << _self.get_mandatory_relations(ht, rec, coll)
#
#	_if _self.responds_to?(:method_before_insertion)
#	_then
#		method_before << _self.perform(:method_before_insertion)
#		_if method_before _isnt _unset
#		_then
#			method_prop_before << method_before.ghc!as_method()
#		_endif
#	_endif
#
#	_catch process_thread.try_method
#
#	       searched_rec << coll.git_create_new_rec( key_fields,
#							needed_fields,
#							needed_relations,
#							childrecs,
#							method_prop_before)
#
#	_endcatch
#	_return searched_rec
#_endmethod
#$

_method git_mapping.auswertung_als_string(auswertung_prop, rec_obj, new_rec)
	##
	info_string << ""
	_if _not (_self.auswertung_hat_aenderungen?(auswertung_prop))
	_then
		_return _self.message(:no_changes_done_on_record)
	_endif
	_if auswertung_prop[:untouched_prop] _isnt _unset
	_then
		info_string +<< write_string(_self.message(:import_info_not_imported_because_of_existing_data), newline_char)
		_for field_name, el _over auswertung_prop[:untouched_prop].fast_keys_and_elements()
		_loop
			# BUG 263
			info_string +<< _self.message(:current_value_in_field_kept,
						      rec_obj.field(field_name).external_name,
						      _self.object_as_string(el[:rec_val]),
						      _self.object_as_string(el[:import_val])
					      )
			info_string +<< newline_char

		_endloop
	_endif
	_if auswertung_prop[:changed_prop] _isnt _unset
	_then
		info_string +<< _self.message(:information_overridden_by_import)

		info_string +<< newline_char

		_for field_name, el _over auswertung_prop[:changed_prop].fast_keys_and_elements()
		_loop

			# BUG 263
			info_string +<< _self.message(:current_value_in_field_overridden,
						      rec_obj.field(field_name).external_name,
						      _self.object_as_string(el[:import_val]),
						      _self.object_as_string(el[:rec_val])
					      )
			info_string +<< newline_char

		_endloop
	_endif
	_if auswertung_prop[:ergaenzt_prop] _isnt _unset
	_then
		info_string +<< _self.message(:information_added)
		info_string +<< newline_char
		_for field_name, el _over auswertung_prop[:ergaenzt_prop].fast_keys_and_elements()
		_loop
			# BUG 263
			info_string +<< _self.message(:actual_value_in_field,
						      rec_obj.field(field_name).external_name,
						      _self.object_as_string(el[:import_val])
					      )

			info_string +<< newline_char

			# End
		_endloop
	_endif

	_if auswertung_prop[:geom_action] _isnt _unset
	_then
		l_field_name << auswertung_prop[:geom_info].as_symbol()

		_if auswertung_prop[:geom_action] _is :replaced
		_then
			info_string +<< _self.message(:geometry_replaced_by_import_geometry,
						      rec_obj.field(l_field_name).external_name
					      )
			info_string +<< newline_char

			l_new_geom << new_rec.perform(l_field_name)
			_if l_new_geom _isnt _unset
			_then
				l_unit << l_new_geom.world.unit.name
				_if auswertung_prop[:old_geom_info_prop][:area] _isnt _unset
				_then
					_if l_new_geom.area = auswertung_prop[:old_geom_info_prop][:area]
					_then
						l_changed_geom? << _false
						l_area_unit << unit_value.new( l_new_geom.area,
									       write_string(l_unit, 2).as_symbol()
									  ).convert_to(:m2)
						info_string +<< _self.message(:area_size_unchanged,
									      l_area_unit
								      )
						info_string +<< newline_char

					_else
						l_changed_geom? << _true

						l_org_size << unit_value.new( auswertung_prop[:old_geom_info_prop][:area],
									      write_string(l_unit, 2).as_symbol()
									 ).convert_to(:m2)

						l_area_unit << unit_value.new( l_new_geom.area,
									       write_string(l_unit, 2).as_symbol()
									  ).convert_to(:m2)

						info_string +<< _self.message(:area_size_changed_from_to,
									      l_org_size,
									      l_area_unit
								      )

						info_string +<< newline_char
					_endif

				_elif auswertung_prop[:old_geom_info_prop][:line_length] _isnt _unset
				_then
					l_line_length << unit_value.new( l_new_geom.line_length,
										 l_unit).convert_to(:m)
					_if l_new_geom.line_length = auswertung_prop[:old_geom_info_prop][:line_length]
					_then

						l_changed_geom? << _false
						info_string +<< _self.message(:line_length_unchanged,
									      l_line_length)
						info_string +<< newline_char
					_else
						l_changed_geom? << _true

						auswertung_prop[:old_geom_info_prop][:area]

						l_old_length << unit_value.new( auswertung_prop[:old_geom_info_prop][:area],
										 l_unit).convert_to(:m)

						info_string +<< _self.message(:line_length_changed_from_to,
									      l_old_length,
									      l_line_length)

						info_string +<< newline_char
					_endif

				_elif auswertung_prop[:old_geom_info_prop][:coordinate] _isnt _unset
				_then
					l_dist << auswertung_prop[:old_geom_info_prop][:coordinate].distance_to(
													   l_new_geom.as_coord()
												    )
					_if l_dist < 1
					_then
						l_changed_geom? << _false
						info_string +<< _self.message(:point_geometry_unchanged)

						info_string +<< newline_char

					_else
						l_changed_geom? << _true

						l_dist << unit_value.new( l_dist,
									  l_unit).convert_to(:m)
						info_string +<< _self.message(:point_geometry_changed_by_distance,
									      l_dist
								      )

						info_string +<< newline_char

					_endif
				_endif
			_endif
		_elif auswertung_prop[:geom_action] _is :untouched
		_then

			info_string +<< _self.message(:existing_geometry_unchanged,

						      rec_obj.field(l_field_name).external_name
					      )
			info_string +<< newline_char
		_elif auswertung_prop[:geom_action] _is :created
		_then
			info_string +<< _self.message(:new_geometry_created,
						      rec_obj.field(l_field_name).external_name
					      )

			info_string +<< newline_char
		_endif
	_endif
	_return info_string, l_changed_geom?

_endmethod
$

# BUG 263
_pragma(classify_level=restricted)
_method git_mapping.object_as_string(a_object)
	##
	_if a_object.responds_to?(:key_fields) _andif
	    a_object.class_name _isnt :select_collection
		#a_object.responds_to?(:source_collection) _andif

	_then

		object_string << ""
		_for a_field _over a_object.key_fields.fast_elements()
		_loop
			_if object_string.size > 0
			_then
				object_string +<< " / "
			_endif
			object_string +<< write_string(a_field.external_name , ": ", a_object.perform(a_field.name))
		_endloop
		_if a_object.responds_to?(:log_aspektfeld)
		_then
			object_string +<< write_string(" (",
						       a_object.log_aspektfeld,
						       ")")
		_elif a_object.responds_to?(:log_aspectfield)
		_then
			object_string +<< write_string(" (",
						       a_object.log_aspectfield,
						       ")")
		_endif

		_return object_string
	_endif
	_if a_object _is _unset _orif
	    a_object = ""
	_then
		a_object << "Leerer Wert"
	_endif

	_return write_string(a_object)
_endmethod
$
# End BUG

_pragma(classify_level=restricted)
_method git_mapping.auswertung_hat_aenderungen?(auswertung_prop)
	##
	_return _not (auswertung_prop[:untouched_prop] _is _unset _andif
		      auswertung_prop[:changed_prop] _is _unset _andif
		      auswertung_prop[:ergaenzt_prop] _is _unset _andif
		      auswertung_prop[:geom_action] _is _unset
		     )
_endmethod
$

_method git_mapping.datenauswertung(auswertung_prop,
				    internal_name,
				    rec_val,
				    val,
				    ergaenzen?,
				    veraendern?
		    )
	##
	rec_val << rec_val.copy()
	val << val.copy()
	# Wert gesetzt
	_if rec_val _isnt _unset
	_then
		# Werte gleich
		_if rec_val ~= val
		_then
			_if ergaenzen?
			_then
				_if auswertung_prop[:untouched_prop] _is _unset
				_then
					auswertung_prop[:untouched_prop] << property_list.new()
				_endif
				# Protokollieren von Daten, die sich intern-extern
				# unterscheiden, aber nicht verändert wurden
				auswertung_prop[:untouched_prop][internal_name] << property_list.new_with(:rec_val,
													  rec_val,
													  :import_val,
													  val)
			_elif veraendern?
			_then
				_if auswertung_prop[:changed_prop] _is _unset
				_then
					auswertung_prop[:changed_prop] << property_list.new()
				_endif
				auswertung_prop[:changed_prop][internal_name] << property_list.new_with(:rec_val,
										      rec_val,
										      :import_val,
										      val)
			_endif
		_endif
	_else
		# rec_wert Unset
		# BUG 263
		_if val _isnt _unset _andif
		    _not (val = "unset")
		_then
			# End BUG
			_if auswertung_prop[:ergaenzt_prop] _is _unset
			_then
				auswertung_prop[:ergaenzt_prop] << property_list.new()
			_endif
			auswertung_prop[:ergaenzt_prop][internal_name] << property_list.new_with(:import_val,
												 val)
		_endif
	_endif

_endmethod
$

_method git_mapping.biggest_area(rope_mit_sec)

	bigg << 0
	bigg_key
	_for key, sr _over rope_mit_sec.fast_keys_and_elements()
	_loop
		_if _not sr.closed?
		_then
			_continue
		_endif

		_if (ps << pseudo_area.new_with_sectors(sr).area) > bigg
		_then
			bigg << ps
			bigg_key << key
		_endif
	_endloop
	_if bigg_key _is _unset
	_then
		_return rope_mit_sec[1], rope.new()
	_endif

	first <<  rope_mit_sec.remove_nth(bigg_key)
	_return first, rope_mit_sec
_endmethod
$

_method git_mapping.add_zuordnung(value_ext, value_int, internal_name, external_name)
	##
	fm << _self.get_field_mapping(internal_name, external_name)
	fm.add_zuordnung(value_ext, value_int)

_endmethod
$

_method git_mapping.get_methoden_name(internal_name, external_name)
	##
	fm << _self.get_field_mapping(internal_name, external_name)
	_return fm.conversion_method
_endmethod
$

_method git_mapping.add_method(feld, methoden_name, internal_name, external_name)
	##
	fm << _self.get_field_mapping(internal_name, external_name)
	fm.add_method(feld, methoden_name)
_endmethod
$

_pragma(classify_level=restricted)
_method git_mapping.convert_prop_keys_to_lowercase(p_prop)
	##
	_for key, element _over p_prop.keys_and_elements()
	_loop
		st_key << write_string(key)
		_if _not (st_key.lowercase = st_key)
		_then
			p_prop[st_key.lowercase.as_symbol()] << p_prop[key]
			p_prop.remove_key(key)
		_endif
	_endloop
_endmethod
$

_method git_mapping.check_and_convert_values( rec, coll, ht, _optional convert_dos_to_ansi?)
	##
	## Routine, die die Daten in rec auf Importtauglichkeit ueberprueft
	##
	_self.convert_prop_keys_to_lowercase(rec)
	det_rec << coll.new_detached_record()

	_for external_name, internal_name _over ht.keys_and_elements()
	_loop
		ext_nam << external_name

		val << rec[ext_nam]

		_if .dsview _is _unset
		_then
			view << gis_program_manager.ghc!a_home_dataset_for_table(_self.database_classname)
		_else
			view << .dsview
		_endif

		coll << view.collections[_self.database_classname.as_symbol()]
		_if (l_field << coll.all_fields[internal_name]) _is _unset
		_then
			_return
		_endif

#		_if val _is _unset
#		_then
#			_continue
#		_endif

		_if convert_dos_to_ansi? _is _true _andif
		    val.responds_to?(:|ghc!from_dbf_to_sw_char()|)
		_then
			val << write_string(val)

			val << val.ghc!from_dbf_to_sw_char()

		_endif
		_if val.responds_to?(:|trim_spaces()|)
		_then
			val << val.trim_spaces()
		_endif
		rec[ext_nam] << val

		# Überpüfe und hole Wert aus Tabellendefinition
		i << 0
		# In schleife, falls mehrere Conversions hintereinander
		_loop @inner_loop
			_if val = ""
			_then
				val << _unset
			_endif
			conv_value << _self.conversion_value(write_string(val), internal_name, ext_nam)

			_if conv_value _isnt _unset
			_then

				rec[ext_nam] << conv_value
				val << rec[ext_nam]
			_else
				_leave @inner_loop
			_endif
			i +<< 1
			# Falls Endlosschleife Abbruch -> "Darwin"->"Dawin"->"Darwin" ...
			_if i > 20
			_then
				_leave @inner_loop
			_endif
		_endloop

		# Definierte Methode auf Wert ausführen
		method_val << _self.methoden_value(val,
						   internal_name,
						   ext_nam)

		_if method_val _isnt _unset
		_then
			rec[ext_nam] << method_val
			val << rec[ext_nam]
		_endif

		int_field << coll.all_fields[internal_name]

		_if val = "unset" _andif
		    _not int_field.mandatory?
		_then
			_continue
		_endif

		ext_class << rec[ext_nam].class_name

		rec[ext_nam] << val

		(val, problem) << ghc_conversion_tool.check_converted_value(val, int_field, det_rec)

		_if _not (val _is _unset _andif
			  problem _isnt _unset)
		_then

			rec[ext_nam] << val
		_endif
		_if problem _isnt _unset
		_then

			_return problem, internal_name, ext_nam
		_endif
	_endloop
_endmethod
$

_method git_mapping.get_field_mapping( internal_name, external_name)
	##
	_for field_mapping _over  _self.git_field_mappings.fast_elements()
	_loop
		_if write_string(field_mapping.internal_fieldname).lowercase = write_string(internal_name).lowercase _andif
		    write_string(field_mapping.external_fieldname).lowercase = write_string(external_name).lowercase
		_then
			_return field_mapping
		_endif
	_endloop
_endmethod
$

_pragma(classify_level=restricted)
_method git_mapping.get_external_conversion_value(p_value,
						  p_field_mapping,
						  p_record
		    )

#	# BUG 252
#	_if val.size > 200
#	_then
#		val << val.slice(1, 200)
#	_endif
#	# End Bug
	l_value << p_value.write_string

	i << 0

	_loop

		_for i_conv _over p_field_mapping.git_conversion_values.fast_elements()
		_loop
			_if i_conv.value_int = l_value
			_then
				l_ext <<  i_conv.value_ext

		#		l_temp_value << l_ext
				_leave

			_endif
		_endloop
		_if l_ext _is _unset _orif
		    l_ext = l_value
		_then
			_leave
		_endif
		_if l_ext _isnt _unset
		_then
			l_value << l_ext
		_endif
		i +<< 1
		_if i > 10
		_then
			_leave
		_endif
	_endloop
	_if l_ext _isnt _unset
	_then
		l_field << p_record.field(p_field_mapping.internal_fieldname.as_symbol())
		l_conv_ext_value << ghc_conversion_tool.check_converted_value(l_ext,
									      l_field,
									      p_record)

		_if l_conv_ext_value _is _unset
		_then
			_return l_ext
		_else
			_return l_conv_ext_value
		_endif
	_endif
_endmethod
$

_method git_mapping.conversion_value(val, internal_name, external_name)
	##
	fm << _self.get_field_mapping( internal_name, external_name)

	# BUG 252
	_if val.size > 200
	_then
		val << val.slice(1, 200)
	_endif
	# End Bug
	conv << _self.source_view.collections[:git_conversion_value].at(val, fm.id)

	_if conv _isnt _unset
	_then

		_return conv.value_int
	_endif

_endmethod
$

_method git_mapping.methoden_value(val, internal_name, external_name)

	# BUG 252
	_if val _is _unset _orif
	    val = "unset"
	_then
		_return
	_endif

	# End BUG
	fm << _self.get_field_mapping( internal_name, external_name)
	_if fm.conversion_method _is _unset
	_then
		_return
	_endif

	method_prop << fm.conversion_method.ghc!as_method()

	_if method_prop _is _unset
	_then
		_return
	_endif
	_if method_prop[:type] _is :field
	_then
		feld_name << method_prop[:field_name]

		# BUG 252
		# Sollte nicht unset sein
		_if .dsview _is _unset
		_then
		view << gis_program_manager.ghc!find_unique_view_for_table(_self.database_classname)
		_else
			view << .dsview
		_endif
		# End BUG

		coll << view.collections[_self.database_classname.as_symbol()]
		_if (l_field << coll.all_fields[internal_name]) _is _unset
		_then
			_return
		_endif
		coll_target << l_field.ghc!target_collection.active_collection

		(val, problem) << ghc_conversion_tool.check_converted_value(val,
									    coll_target.field(feld_name),
									    coll_target.new_detached_record()
						      )
		_if val.inherits_from?(ds_record)
		_then
			sel_col << {val}
		_else

			sel_col << rope.new_from(coll_target.select(predicate.new(feld_name,
										  :eq,
										  val)
							     )
					)
		_endif
		_try
			_if sel_col.size = 1
			_then
				_return sel_col.an_element()
			_elif sel_col.size > 1
			_then
				condition.raise(:information,
						:info_type,
						_self.message(:join_record_not_unique).as_symbol(),
						:pm_object_text_info,
						_self.message(:join_record_not_unique_detail,
							      coll_target.external_name,
							      coll_target.field(feld_name).external_name,
							      sel_col.size,
							      val)
					  )
				_return sel_col.an_element()

			_endif
		_when error
		_endtry
		_return

	_endif

	_if method_prop[:method_name] _isnt _unset _andif
	    val.responds_to?(method_prop[:method_name])
	_then
		_if method_prop[:method_args] _is _unset
		_then
			erg_val << val.perform(method_prop[:method_name])
		_else
			erg_val << val.perform(method_prop[:method_name], _scatter method_prop[:method_args])
		_endif

		_if erg_val _isnt _unset
#		_andif
#		    erg_val.inherits_from?(charindex_mixin) _andif
#		    val.inherits_from?(charindex_mixin)
		_then
			val << erg_val
		_endif
	_endif

	_return val

_endmethod
$

_method git_mapping.check_mandatory_field_values(trec, default_values)
	##
	_for fd _over trec.all_fields.elements()
	_loop
				# suche pflichtfelder des kinds
				#				cpf << childpflichtfelder << _self.bestimme_pflichtfelder( childcoll.record_exemplar)

				#cpf_with_chevron << set.new()
				#_for cfn _over cpf.elements()
				#_loop
				#	cpf_with_chevron.add(cfn.with_chevron)
				#_endloop

#				_if child_ht.keys.includes_all?(cpf)
#				#_if set.new_from(child_ht).includes_all?(cpf_with_chevron)
#				_then
		_if fd.responds_to?(:mandatory?) _andif
		    fd.mandatory? _andif
		    trec.perform(fd.name) _is _unset _andif
		    fd.type _isnt :sys_id  _andif
		    (_not fd.key.matches?("dd!join*") )

		_then
			# print(fd)
			# Behandlung noch einfügen
			_self.changed(:process_status,
				      :warning_mandatory_field_unset,
				      trec,fd.name,fd.type)
		_endif
	_endloop

	_return trec
_endmethod
$

_method git_mapping.insert_child_records(rec, ht,
					 process_thread,
					 geofield, parentcoll,
					 _optional mode,
					 add_catalogue_values?, default_values,
					 convert_dos_to_ansi?
		    )
	##
	## Fügt relational Verknüpfte Records ein.
	##
	# Schaue nach kind Mappings

	_self.changed(:process_status, :insert_childs)

	_local inserted_childs << hash_table.new()

	_if _self.childs_to_read _isnt _unset _andif
	    (_not _self.childs_to_read.empty?)
	_then
		# Loop über Kind-Mappings
		_for childmap _over _self.childs_to_read.elements()
		_loop
			_local childcoll << .dsview.collections[childmap.database_classname.as_symbol()]
			# finde join_field für das kindmapping
			childfieldname << _self.get_joinfieldname_for_child(parentcoll.record_exemplar,
									    childmap.database_classname.as_symbol())
			# Hole Hash table der auf dem Kind gemappten Felder
			_local child_ht << childmap.get_my_hash_table(geofield)

			# Kindfeldname
			_if childfieldname _isnt _unset
			_then
				inserted_childs[childfieldname] << childmap.write_record( rec, childcoll,
											  process_thread,
											  child_ht,
											  mode,
											  geofield,
											  add_catalogue_values?,
											  default_values,
											  convert_dos_to_ansi?)

			_endif
		_endloop
	_endif

	_return inserted_childs

_endmethod
$

_method git_mapping.get_external_fieldname_for_field(field)

	# Lese erst eigene Feldwerte

	_for fm _over _self.git_field_mappings.elements()
	_loop
		_local fieldkey << fm.internal_fieldname.as_symbol()

		_if fieldkey _is field.as_symbol()
		_then
			extfn << write_string(fm.external_fieldname).as_symbol()
			_return extfn
		_endif
	_endloop
	_return field

_endmethod
$

_method git_mapping.description
	##
	## Liefer kurze Mapping Beschreibung
	##
	_local sep << " | "
	_local info << write_string( _self.id,sep,
			       _self.message(:childs),
			       _self.childs_to_read.size,sep,
			       _self.message(:fields),
			       _self.git_field_mappings.size)
	_return info
_endmethod
$

_method git_mapping.max_external_name_length
	##
	##  Load the slot contents of self to the memory_mapping
	##
	_local max << 0
	_for name _over _self.all_subext_names.elements()
	_loop
		_if (mysize << name.size) > max _then
			max << mysize
		_endif
	_endloop
	_return max

_endmethod
$

_method git_mapping.check_catalogue_value(kf, el, val, coll, _optional default_values)
	##
	## Diese Methode prüft für die mit Katalogen zugeordneten
	## Felder die Werte und ergänzt gegebenenfalls die Kataloge um
	## die entsprechenden Einträge.
	##
	_local name_katalog << el[1]
	_local feld_katalog << el[2]

	default_values << default_values.default(hash_table.new_with(:string, "unbekannt",
								     :number, 0))
	_local tab_hash   << hash_table.new()
	_local v          << coll.source_view
	_local equal_prec << _self.nrmb_float_equality_precision

	_if val.inherits_from?(charindex_mixin)
	_then
		#val << val.remove_trailing(%space)
		_if val.size = 0
		_then
			#val << _unset
			# Füge default Wert ein wenn Mandatory Field!, sonst unset
			_if coll.descriptor.all_fields[kf].mandatory?
			_then
				val << default_values[:string]
			_else
				val << _unset
			_endif

		_endif
	_endif

	data_type << coll.descriptor.all_fields[kf].type.phys_type
	_if data_type _is :ds_double _orif
	    data_type _is :ds_float
	_then
		mypred << predicate.gt(feld_katalog,
				       val - equal_prec) _and
			  predicate.lt(feld_katalog,
				       val + equal_prec)# _and
			  #feld_katalog
	_else
		mypred << predicate.eq(feld_katalog,val) #_and
			  #feld_katalog
	_endif

	_local katalogcoll << v.collections[name_katalog]
	_if katalogcoll.select(mypred).an_element() _is _unset
	_then
		# Hier muß nun ein entsprechender Katalogeintrag eingefügt
		# werden...
		_local ctrec << _unset
#		_for fidx _over range(1, t_info[5].size)
#		_loop
			_if val _isnt _unset
			_then
				ctrec << ctrec.default( katalogcoll.new_detached_record() )
				ctrec.perform ( feld_katalog.with_chevron,  val) #t_info[ 4 ][ fidx ] )
			_endif
		#_endloop

#		_if ctrec _isnt _unset
#		_then
#			# Schaue ob selbst Katalogezuordnungen bestehen...
#			# rekursiv mit Methode auf dsrec...
#			ctrec << ctrec.ghc!check_catalogue_values( default_values)
#
#			# ctrec.perform(t_info[5].with_chevron,val)
#			rec << katalogcoll.insert(ctrec)
#			# show(rec)
#		_endif
	_endif

_endmethod
$

_pragma(classify_level=restricted)
_method git_mapping.get_key_values(ht,rec, coll)
	##
	key_hash << hash_table.new()
	_for external_name,internal_name _over ht.keys_and_elements()
	_loop
		_if coll.key_field_names.includes?(internal_name)
		_then
			key_hash[internal_name] << rec[external_name.write_string.lowercase.as_symbol()]
		_endif
	_endloop

	_return key_hash
_endmethod
$

_pragma(classify_level=restricted)
_method git_mapping.has_autogenerated_key_fields?(coll)
	##
	_for f _over coll.key_fields.fast_elements()
	_loop
		_if f.generator _isnt _unset
		_then
			_return _true
		_endif
	_endloop
	_return _false
_endmethod
$

_pragma(classify_level=restricted)
_method git_mapping.get_mandatory_fields(ht,rec, coll)
	##
	needed_fields_hash << hash_table.new()

	phys_rope_field << rope.new()

	_for phys_field _over coll.physical_fields.fast_elements()
	_loop
		_if phys_field.is_key? _is _false  _andif
		    phys_field.mandatory?
		_then
			phys_rope_field.add(phys_field.name)
		_endif
	_endloop

	_for external_name,internal_name _over ht.keys_and_elements()
	_loop
		_if phys_rope_field.includes?(internal_name)
		_then
			needed_fields_hash[internal_name] << rec[external_name.write_string.lowercase.as_symbol()]
		_endif
	_endloop

	_return needed_fields_hash
_endmethod
$

_pragma(classify_level=restricted)
_method git_mapping.get_mandatory_relations(ht,rec, coll)
	##
	needed_joins_hash << hash_table.new()

	_for external_name,internal_name _over ht.keys_and_elements()
	_loop
		_if coll.join_field_names.includes?(internal_name)
		_then
			needed_joins_hash[internal_name] << rec[external_name.write_string.lowercase.as_symbol()]
		_endif
	_endloop
	_return needed_joins_hash
_endmethod
$

_pragma(classify_level=restricted)
_method git_mapping.xml_field_vec
	##
	_return {
			:database_classname,
			:method_after_insertion,
			:method_before_insertion,
			:level,
			:parent_classname

	}
_endmethod
$

_pragma(classify_level=restricted)
_method git_mapping.xml_records_vec
	##
	_return {

			:git_field_mappings
	}
_endmethod
$

_pragma(classify_level=restricted)
_method git_mapping.ghc_xml!insert_record(p_coll, p_data_prop)
	##
	l_transfer << p_data_prop[:git_transfer]
	p_data_prop.remove_key(:git_transfer)
	l_rt << record_transaction.new_insert(
			p_coll,
			p_data_prop).run()
	_if l_transfer _isnt _unset
	_then
		l_rt.git_transfers.add(l_transfer)
	_endif

	_return l_rt

_endmethod
$

_pragma(classify_level=restricted)
git_mapping.define_shared_variable(:ghc_message_accessor,
				    _unset,
				    :public)
$

_pragma(classify_level=restricted)
_method git_mapping.ghc!message_handler()
	##
	_if (l_ma << _self.ghc_message_accessor) _is _unset
	_then
		_self.ghc_message_accessor << l_ma <<
			message_handler.new( :ghc_dcc_dm_functionality )
	_endif
	_return l_ma
_endmethod
$
_pragma(classify_level=restricted)
_method git_mapping.referenced_collection()
	## 
	## 
	_if (l_view_name << _self.view_name) _is _unset _orif
	    (l_view << gis_program_manager.cached_dataset(l_view_name.as_symbol())) _is _unset 
	_then
		_return
	_endif
	_return l_view.collection(_self.database_classname.as_symbol())
_endmethod
$

_pragma(classify_level=restricted)
_method git_mapping.mapping_info()
	## 
	##
	l_res << ""
	_if (l_coll << _self.referenced_collection()) _isnt _unset
	_then
		l_name << l_coll.external_name
	_else
		l_name << _self.database_classname
	_endif
	l_res +<< _self.message(:table_info, _self.level, l_name, _self.git_field_mappings.size)
	l_res +<< newline_char
	_for i_field_mapping _over _self.git_field_mappings.fast_elements()
	_loop
		_if l_coll _isnt _unset _andif
		    (l_field << l_coll.field(i_field_mapping.internal_fieldname.as_symbol())) _isnt _unset 
		_then
			l_field_name << l_field.external_name
		_else
			l_field_name << i_field_mapping.internal_fieldname
		_endif  
		l_res +<< _self.message(:field_mapping, l_field_name, i_field_mapping.external_fieldname)
		l_res +<< newline_char	
	_endloop
	_for i_child _over _self.childs_to_read.fast_elements()
	_loop
		l_res +<< i_child.mapping_info()
	_endloop 
	_return l_res
_endmethod
$







