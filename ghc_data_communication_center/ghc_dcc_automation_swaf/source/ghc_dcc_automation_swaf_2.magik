#% text_encoding = iso8859_1
##
##  Auto-generated by Dialog Designer ( 01.02.2010 )
##
##  System.user_mame = uli.naedelin
##
##  SUPPLIMENTARY code for gui class 'ghc_dcc_automation_swaf'
##    - add/redefine code here, it will not be auto-modified.

ghc_dcc_automation_swaf.def_property(
	:current_rec,
	_unset,
	:public)
$

_pragma(classify_level=restricted)
_method ghc_dcc_automation_swaf.run_selected_automation()
	##
	l_rec << _self.current_rec #.items[:auto_config_list].selected_records.an_element()
	_if l_rec _isnt _unset
	_then
		_self.run_with_auto_config(l_rec)
	_endif
_endmethod
$

_pragma(classify_level=restricted)
_method ghc_dcc_automation_swaf.run_with_auto_config(p_rec)
	##
	l_parameter_prop << property_list.new()
	l_autom_plugin << _self.get_automation_plugin()

	_for i_meta_data _over p_rec.git_dcc_meta_datens.fast_elements()
	_loop
		l_import? << i_meta_data.import?.default(_false)

		_if l_import?
		_then
			_if (l_filename << i_meta_data.get_filename()).includes?(%*)
			_then
				
				l_dc << directory_channel.new(p_rec.path,
							      l_filename.write_string
							  )
				l_vec << rope.new()
				_protect
					_loop 
						l_file << l_dc.get_full()
						_if l_file _is _unset
						_then
							_leave
						_endif
						l_vec.add(l_file)
					_endloop 
				_protection
					l_dc.close()
				_endprotect 			      
			_else
				l_vec << rope.new_with(
						 system.pathname_down(
							 p_rec.path,
							 l_filename
							))
			_endif
			
			_for i_file _over l_vec.fast_elements()
			_loop
				l_autom_plugin.start_import(
					i_meta_data,
					i_file,
					_false,
					_true,
					_true )
			_endloop 
		_else
			l_autom_plugin.start_export(
				i_meta_data,

				system.pathname_down(p_rec.path,
						     i_meta_data.get_filename()),
				_unset,
				_false,
				_true,
				_false )
		_endif
	_endloop
_endmethod
$
_pragma(classify_level=restricted)
_method ghc_dcc_automation_swaf.get_automation_plugin()

	l_app << _self.get_application()
	_return l_app.plugin(:ghc_dcc_automation)

_endmethod
$

_pragma(classify_level=restricted)
_method ghc_dcc_automation_swaf.get_application()
	##

	_return !current_application!

_endmethod
$

_pragma(classify_level=restricted)
_method ghc_dcc_automation_swaf.record_selected(a_selection)
	##
	_if a_selection.empty?
	_then
		_self.current_rec << _unset
	_else
		a_node << a_selection.an_element()
		_self.current_rec << a_node.key
	_endif

	_self.update_all()
_endmethod
$

_pragma(classify_level=restricted)
_method ghc_dcc_automation_swaf.update_all()
	##
	_if _self.current_rec _is _unset
	_then
		.items[:auto_config_note_text_field].value << _self.message(:no_auto_config_record_selected)
	_else
		.items[:auto_config_note_text_field].value << _self.current_rec.note.default("")
	_endif
_endmethod
$

_pragma(classify_level=restricted)
_method ghc_dcc_automation_swaf.double_click_record(a_selection)

#	_if a_selection.empty?
#	_then
#		_self.current_rec << _unset
#	_else
#		a_node << a_selection.an_element()
		_self.current_rec << a_selection.key
#	_endif
	_if _self.current_rec _isnt _unset
	_then
		l_em << _self.get_editor_manager()
		l_em.activate_editor_for_object(_self.current_rec)
	_endif
_endmethod
$

_pragma(classify_level=restricted)
_method ghc_dcc_automation_swaf.get_editor_manager()
	##
	l_app << _self.get_application()
	_return l_app.component(:editor_manager)
_endmethod
$
