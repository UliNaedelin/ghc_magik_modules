#% text_encoding = iso8859_1
_package sw
#
# GIT Mapping Editor
#
# Teilmodul des GIT- Communicator
#
# GIT HydroS Consult GmbH, Freiburg i. Br.
##
## Objektklasse:             ghc_mapping_definator
##
## Vererbung:                git_engine_model
##
## Beschreibung:             Editor zur Definition des Feld
##                           Mappings im communicator
##


#
# Exemplardefinition
def_slotted_exemplar( :ghc_mapping_definator,
		      {
			      {:actual_fields, _unset },
			      {:actual_transfer_name, _unset},
			      {:anything_changed?,  _false},
			      {:child_classes, _unset},
			      {:child_classes_in_level, _unset},
			      {:child_classes_names, _unset },
			      {:class_mappings, _unset},
			      {:class_names, _unset },
			      {:classes, _unset},
			      {:current_mapping, _unset, :writable},
			      {:dsview, _unset },
			      {:external_field_names, _unset},
			      {:external_field_names_to_map, _unset},
			      {:all_external_field_names_to_map, _unset},
			      {:field_mappings, _unset, :writable},
			      {:field_value, _unset, :writable},
			      {:fmapcoll, _unset , :writable},
			      {:geofield_selected?, _unset},
			      {:gisviews, _unset},
			      {:information, "", :writable},
			      {:level, _unset, :writable},
			      {:mapcoll, _unset , :writable},
			      {:maplist, _unset },
			      {:mapped_geometry_fields, _unset},
			      {:mapping_dsview, _unset , :writable},
			      {:max_edit_level, _unset, :writable},
			      # {:menu_items,_unset,:writable},
			      {:menu_items_novis,_unset,:writable},
			      {:objectlist, _unset },
			      {:owner, _unset, :writable},
			      {:myowner_class, _unset},
			      {:select_map, _unset },
			      {:selected_child_class, _unset},
			      {:selected_class_in_level, _unset},
			      {:selected_field, _unset},
			      {:show_field_types?, _false},
			      # {:sub_menus, _unset},
			      {:the_mapping, _unset, :writable},
			      {:transfer_object, _unset},
			      {:transfer_id, _unset},
			      {:used_classes_in_level, _unset }
		      },
		      {:ghc_wizard_base, :ghc_dcc_font_mixin} )
$


# Shared Variable/Constant
_pragma(classify_level=restricted)
ghc_mapping_definator.define_shared_constant(:max_geometry_fields,
					     1,:public)
$

ghc_mapping_definator.define_shared_constant(:pane_names,
				   ## List of the pane ids, these are listed in the order that
				   ## they appear in the entrainment.
				   { :class_selector, :field_selector } ,
				   _false )
$
ghc_mapping_definator.define_shared_constant(:finish_mode,
					     :finish_end ,
				   _false )
$

# NEW: 4.0
_pragma(classify_level=restricted)
ghc_mapping_definator.define_shared_constant(:help_available?,
				   ## This should be overridden by subclasses if help is
				   ## available. If set true, a help button will be added and, on
				   ## selection, help will be displayed for each panel using the
				   ## help id <pane_name>? by default. The id may be overridden by
				   ## subclassing the method pane_help_id().
				   _true ,_false)
$

_pragma(classify_level=restricted)
_method ghc_mapping_definator.init_actions()
	## 
	## 
	_self.add_action(sw_action.new(:view,
				       :toolbar_control, :text_choice_item,
				       :engine, _self,
				       :value_change_message, :view_changed|()|,
				       :items, _self.view_items(),
				       :tooltip, _self.message(:view_tt)
				   )
	      )
_endmethod
$

_pragma(classify_level=restricted)
_method ghc_mapping_definator.view_items()
	## 
	## 
	l_vec << gis_program_manager.databases
	
	l_sc_vec << sorted_collection.new_from(l_vec, _proc(el1,el2)
							      _return el1.external_name _cf el2.external_name
					       _endproc )

	l_final_vec << rope.new_for(l_vec.size)
	
	_for i_view _over l_sc_vec.fast_elements()
	_loop
		l_final_vec.add({i_view.name, i_view.external_name})
	_endloop
	_return l_final_vec
_endmethod
$


_method ghc_mapping_definator.create_wizard_pane(p_myowner,id)
	## This method creates the UI for each pane, as identified by


	_return _self.perform(:a.concatenation(:create_pane_, id, :|()|), p_myowner)

_endmethod
$
_method ghc_mapping_definator.goto_view_selection()
	##
	_self.goto(_self.pane_names[1])
_endmethod
$
_method ghc_mapping_definator.goto_class_selection()
	##
	_self.goto(_self.pane_names[2])
_endmethod
$
_method ghc_mapping_definator.goto_field_selection()
	##
	_self.goto(_self.pane_names[3])
_endmethod
$

_pragma(classify_level=restricted)
_method ghc_mapping_definator.activate_in(f)
	## defines the basic Wizard UI structure, and calls the
	## subclassable create_wizard_pane() method to create the wizard
	## panes.
	_local n << _self.no_of_panes
	_local p,s
	f.height << 500
	_if n < 1
	_then condition.raise(:unset_pane_names, :class , _self.class_name)
	_endif
	l_rc << rowcol.new(f, _unset, 1, _unset,
			   :default_col_alignment, :fill,
			   :default_row_alignment, :fill,
			   :row_resize_values, {0.75, 0, 0,0.25,0},
			   :row_spacing, 6,
			   :outer_spacing, 6)
	
	.parent_panel << window_stack.new(l_rc)
	.parent_panel.col_alignment << :fill
	.parent_panel.row_alignment << :fill
	.parent_panel.default_col_alignment << :fill
	.parent_panel.default_row_alignment << :fill
	.index << 1
	.parent_panel.resize_x? << _true
	.parent_panel.resize_y? << _true 
	_for i _over 1.upto(n)
	_loop
		_local pn << _self.pane_names[i]
		_local c << _self.create_wizard_pane( .parent_panel, pn )
		_if c _is _unset
		_then condition.raise(:unset_pane, :class , _self.class_name )
		_endif
		c.resize_x? << _true
		c.resize_y? << _true 
		c.name << pn
	_endloop
	.parent_panel.value << _self.pane_names[ .index]
	
	s << panel_separator.new(l_rc)
	#s.x << 0
	
	#_self.create_mapping_panel(p)
	#	p.start_row()
	.menu_items[:mapping_list_label] << label_item.new(l_rc, _self.message(:zugeordnete_mappings))

	.menu_items[:mapping_list] << lv << simple_list_item.new(l_rc,
								 :model, _self,
								 :change_selector, :|select_mapping()|,
								 :aspect, :mache_mapping_liste)
	.menu_items[:mapping_list].items << _self.mache_mapping_liste							 
		#list_box_item.new(l_rc, _self,:mache_mapping_liste, :|select_mapping()|,_unset ,
				#			      10,100,:one)
	
	.menu_items[:mapping_list].min_width << 80

	l_rc2 << rowcol.new(l_rc, 1, _unset, _unset,
			    :col_spacing, 6,
			    :col_resize_values, {0,0,0,1})
	.prev_button << button_item.new(l_rc2, _self.message(:back), _self,
					:|do_back()| )
	.prev_button.visibility << _false
	.next_button << button_item.new(l_rc2, _self.message(:next), _self,
					:|do_next()| )
	
	_if _self.finish_mode = :finish_always
	_then
		nb << button_item.new(l_rc2,_self.message(_self.finish_button_id),
				      _self, :|int!finish()| )
		.finish_button << nb
	_else
		nb << .next_button
	_endif
	cb << button_item.new(l_rc2,_self.message(:cancel), _self, :|do_cancel()|)

	_if _self.help_available?
	_then
		# The resized label item keeps the help button in the bottom
		# right corner.			   )
		
		button_item.new(l_rc2,_self.message(:help),_self,:|do_pane_help()|,
				:col_alignment, :right
			    )
	_endif
	_self.view_changed(_self.action(:view).value)
	_return l_rc
_endmethod
$

_pragma(classify_level=restricted)
_method ghc_mapping_definator.new( _gather args )
	##
	>> _clone.init( _scatter args )
_endmethod
$

_pragma(classify_level=restricted)
# NEW: 4.0
_method ghc_mapping_definator.init( my_application,
				    my_plugin,
				    an_owner, a_transfer , _optional external_field_names_to_map) # , a_mapping, a_message )
# END
	##
	## Initialisierung
	##
	_super.init(my_application,
		    my_plugin)
	.mapped_geometry_fields << 0
	.geofield_selected? << _false
# OLD: 4.0
# 	.grs << grs
# END
	
	.external_field_names << rope.new()
	.external_field_names_to_map << external_field_names_to_map.as_sorted_collection()
	.all_external_field_names_to_map << .external_field_names_to_map.copy()
	.actual_transfer_name << a_transfer.name
	.transfer_object << a_transfer
	.transfer_id << a_transfer.id
	.owner << an_owner
	_self.add_dependent(_self)
	.sub_menus << hash_table.new()

	_self.reset
# OLD:
#	.message_accessor << message_handler.new(:ghc_dcc_dialog)
# END

	_self.update_class_mappings
	>> _self

_endmethod
$

_pragma(classify_level=restricted)
_method ghc_mapping_definator.update_class_mappings
	##
	.class_mappings << hash_table.new()
# NEW:
	_if .transfer_object _isnt _unset
	_then
# END

		_if _not .transfer_object.git_mappings.empty?
		_then
			# Read the mappings from the database
			_for i _over .transfer_object.git_mappings.elements()
			_loop
				# Änderung ohne Memmappings
				.class_mappings[i.database_classname.as_symbol()] << i
			_endloop
		
		_endif
		_self.fill_slots_with_loaded_data
# NEW:
	_endif
# END

_endmethod
$


_pragma(classify_level=restricted)
_method ghc_mapping_definator.create_pane_field_selector(p_pane)
	## 
	## 
	l_rc << rowcol.new(p_pane, _unset, 1)
	l_rc.col_alignment << :fill
	l_rc.row_alignment << :fill
	l_rc.row_spacing << 6
	l_rc.row_resize_values << {0, 1, 0,0}
	l_rc2 << rowcol.new(l_rc, 1, _unset)
	l_rc2.col_alignment << :fill
	l_rc2.col_resize_values << {0, 1}
	l_rc2.col_spacing << 6
	.menu_items[:class_label] << label_item.new(l_rc2, _self.message(:class_name))
	.menu_items[:class_name] << label_item.new(l_rc2, "")
	l_rc3 << rowcol.new(l_rc, 1, _unset)
	l_rc3.col_alignment << :fill
	l_rc3.col_resize_values << {0.5, 0.5}
	l_rc3.col_spacing << 6
	l_rc_left << rowcol.new(l_rc3, _unset, 1)
	l_rc_left.row_alignment << :fill
	l_rc_left.row_resize_values << {0, 1}
	l_rc_left.row_spacing << 6
	.menu_items[:field_lister_label] << label_item.new(l_rc_left, _self.message(:fields))
	.menu_items[:field_lister] << simple_list_item.new(l_rc_left,
							   :model, _self,
							   :aspect, :mache_feld_liste,
							   :change_selector, :|changed_field()|)
	l_rc_right << rowcol.new(l_rc3, _unset, 1)
	l_rc_right.row_alignment << :fill
	l_rc_right.row_resize_values << {0, 1}
	l_rc_right.row_spacing << 6
	.menu_items[:external_field_lister_label] << label_item.new(l_rc_right, _self.message(:external_fields))
	.menu_items[:external_field_lister] << simple_list_item.new(l_rc_right,
								    :model, _self,
								    :aspect, :mache_externe_feld_liste,
								    :change_selector, :|changed_external_field()|)

	#		list_box_item.new(l_rc_right, _self, :mache_externe_feld_liste, :|changed_external_field()|, _unset, 14, 50, :one)
	l_rc4 << rowcol.new(l_rc, 1, _unset)
	l_rc4.col_spacing << 6
	.menu_items[:map_to_label] << label_item.new(l_rc4,_self.message(:map_to))
	.menu_items[:map_to_field_name] << text_item.new(l_rc4, "")
	l_rc5 << rowcol.new(l_rc, 1, _unset)
	l_rc5.col_spacing << 6
	.menu_items[:shorten] << button_item.new( l_rc5, _self.message(:shorten_fieldname), _self, :shorten_fieldname|()| )
	.menu_items[:add_field_mapping] << button_item.new( l_rc5, _self.message(:add_field_mapping), _self, :add_field_mapping|()| )
	.menu_items[:visible_fields_only] << toggle_item.new(l_rc5, _self.message(:show_only_visible_fields),
							     :model, _self,
							     :change_selector, :update_field_list,
							     :value ,_true )
	_return l_rc
_endmethod
$

_pragma(classify_level=restricted)
_method ghc_mapping_definator.create_pane_class_selector(p_pane)
	## 
	## 
	l_rc << rowcol.new(p_pane, _unset, 1)
	l_rc.col_alignment << :fill
	l_rc.row_alignment << :fill
	l_rc.default_col_alignment << :fill
	l_rc.default_row_alignment << :fill
	l_rc.row_spacing << 6
	l_rc.row_resize_values << {1, 0}
	l_rc2 << rowcol.new(l_rc, _unset, 2)
	l_rc2.col_alignment << :fill
	l_rc2.col_resize_values << {0, 1}
	l_rc2.row_resize_values << {0, 0, 0.8, 0.2, 0}
	l_rc2.col_spacing << 6
	l_rc2.row_spacing << 6
	label_item.new(l_rc2, _self.message(:view_selection))
	_self.action(:view).place_control_on(l_rc2, :dialog)
	label_item.new(l_rc2,
		       _self.message(:child_class_name_label))
	.menu_items[:myowner_class_names] << label_item.new(l_rc2, "--")
	.menu_items[:class_lister_label] << label_item.new(l_rc2, _self.message(:object_classes))
	.menu_items[:class_lister] << simple_list_item.new(l_rc2,
							   :model, _self,
							   :aspect, :mache_class_liste,
							   :change_selector, :|changed_class()|)
	.menu_items[:class_lister].min_height << 60
	.menu_items[:child_lister_label] << label_item.new(l_rc2,_self.message(:myowner_class_name_list))
	.menu_items_novis[:child_lister] << simple_list_item.new(l_rc2,
								 :model, _self,
								 :aspect, :mache_child_liste)
	.menu_items_novis[:child_lister].visibility << _false 
	
	l_rc3 << rowcol.new(l_rc, _unset, 2)

	l_rc3.col_spacing << 12
	.menu_items[:upbutton] << button_item.new( l_rc3, _self.message(:child_level), _self, :level_up )
	.menu_items[:downbutton] << button_item.new( l_rc3, _self.message(:myowner_level), _self, :level_down )
	
	_return l_rc
_endmethod
$

_pragma(classify_level=restricted)
_method ghc_mapping_definator.reset()
	_self.reset
_endmethod
$

_pragma(classify_level=restricted)
_method ghc_mapping_definator.reset
	##
	## Init
	##
	_local maxdepth << 50
	.mapping_dsview << gis_program_manager.ghc!find_unique_view_for_table("git_mapping")
	.mapcoll << .mapping_dsview.collections[:git_mapping]
	.fmapcoll << .mapping_dsview.collections[:git_field_mapping]

	# Hole transfer erneut
	.transfer_object << .mapping_dsview.collections[:git_transfer].at( .transfer_id)
	.menu_items << hash_table.new()
	.menu_items_novis << hash_table.new()
	.level << 0
	.used_classes_in_level << simple_vector.new(maxdepth)
	_for l _over range(1, maxdepth)
	_loop
		.used_classes_in_level[l] << hash_table.new()
	_endloop

	.field_mappings << rope.new()
	.myowner_class << simple_vector.new(maxdepth)
	.child_classes_in_level << simple_vector.new(maxdepth)
	.selected_class_in_level << simple_vector.new(maxdepth)
	.classes << simple_vector.new(maxdepth)
	.class_mappings << hash_table.new()                 # Nur Für Mappings in erster ebene !
	.external_field_names << rope.new()
	.objectlist << rope.new()
	.mapped_geometry_fields << 0

	.transfer_object << .mapping_dsview.collections[:git_transfer].at( .transfer_id)
	_self.update_class_mappings

	_self.update_mache_mapping_liste()
_endmethod
$

_method ghc_mapping_definator.update_field_list
	##
	_self.changed(:mache_feld_liste)
_endmethod
$

_pragma(classify_level=restricted)
_method ghc_mapping_definator.activate_in_win32( a_frame )
	##
	## Modifizierte activate_in methode fuer die neue GUI
	##
	pan << panel.new( a_frame )
	_local ms << _self.menu_system
	# Erzeuge Menu
	# ms.make_menubar()

	_self.activate_in(a_frame)

	pan.start_row()
	ms.make_statusbar(a_frame)
_endmethod
$

_pragma(classify_level=restricted)
_method ghc_mapping_definator.select_mapping(selrec_vec, _optional double_click?)
	##
	## Fragt nach, Ob Mappingeintrag mit dem Identifier gelöscht
	## werden soll...
	##
	selrec << selrec_vec.an_element()
	_if double_click? _is _true 
	_then
		_if _self.show_alert(_self.message(:edit_or_delete),
				     _self.message(:edit),_self.message(:delete))
		_then
			_self.activate_editor_for_object(selrec)
# OLD:
#			_self.activate_editor_for_object(selrec)
#			#.sub_menus[:rwo_editor].add_dependent(_self)
# END
		_else
			_if _self.show_alert(_self.message(:really?),
					     _self.message(:yes) , _self.message(:no))
			_then
				external_fieldname << ""
				ext_fieldname_vec << rope.new()
				ok? << .mapping_dsview.start_lwt()
				_protect
					# Merke externen Feldnamen ...
					_if selrec.source_collection.name ~= :git_mapping
					_then
						external_fieldname << write_string( selrec.perform(:external_fieldname))
					_else
						l_child_mapping_vec << rope.new_with(selrec)
						_loop
							l_new_childs << rope.new()
							_for i_child_mapping _over l_child_mapping_vec.fast_elements()
							_loop
								_for i_field_mapping _over i_child_mapping.git_field_mappings.elements()
								_loop
									ext_fieldname_vec.add( i_field_mapping.external_fieldname.deep_copy())
								_endloop
								l_new_childs.add_all_last(i_child_mapping.childs_to_read)
							_endloop
							_if l_new_childs.size = 0
							_then
								_leave
							_endif
							l_child_mapping_vec << l_new_childs.copy()
						_endloop

					_endif
					selrec.delete()
					ok? << _true
				_protection
					.mapping_dsview.end_lwt(ok?)
				_endprotect

				# Starte abhängigkeiten ...
				_if ok? _andif
				    external_fieldname _isnt _unset _andif
				    ( _not external_fieldname.empty?)
				_then
					_self.external_fieldname_removed(external_fieldname)
				_endif

				_if ok?
				_then
					_for i_field_name _over ext_fieldname_vec.fast_elements()
					_loop
						_self.external_fieldname_removed(i_field_name)
					_endloop
				_endif

				_self.update_mache_mapping_liste()
				_self.update_class_mappings

			_endif
		_endif
	_endif

	_self.moveto(selrec)

_endmethod
$

_method ghc_mapping_definator.external_fieldname_removed(efn)
	##
	## METHODE MACHT 2 sachen :
	## 1. entfernt externen feldnamen aus zu gemappten feldern...
	## 2. fügt ihn zu den zu mappenden hinlder
	_local newlist << rope.new()
	_for i _over .external_field_names.elements()
	_loop
		_if _not (write_string(i).as_symbol() = efn.as_symbol())
		_then
			newlist.add_last(i)
		_endif
	_endloop
	.external_field_names << newlist.copy()

	# Füge wieder in list hinzu wenn zu mappend
	_local found? << _false
        _local fielddefinition_to_add_again
        _for i _over .all_external_field_names_to_map.elements()
	_loop @searcher
		_if (write_string(i.name).as_symbol() = efn.as_symbol())
		_then
			found? << _true
			 fielddefinition_to_add_again << i
			#  print(i)
			_leave @searcher
		_endif
	_endloop

	_if found?
	_then
		.external_field_names_to_map.add(fielddefinition_to_add_again)
		_self.update_mache_externe_feld_liste()
	_endif
_endmethod
$
_method ghc_mapping_definator.moveto(selrec)
#	##
_endmethod
$

_pragma(classify_level=restricted)
_method ghc_mapping_definator.mache_gisview_liste
	##
	## Erzeugt die Liste der vorhandenen Schalvos

	_self.status << :busy
	_self.changed(:status_string)

	.gisviews << rope.new()
	_local gisview_names << rope.new()

	view_vec << rope.new()
	_for i_view _over gis_program_manager.cached_datasets()
	_loop
		_if i_view.class_name _is :case_ds_view
		_then
			_continue 
		_endif
		view_vec.add(i_view)
	_endloop
	l_sorted_view << view_vec.as_sorted_collection(
				 _proc (el1, el2)
					 _return el1.external_name _cf el2.external_name
				 _endproc
				  )
	_for a_view _over l_sorted_view.fast_elements()
	_loop
		.gisviews.add_last(a_view)
		gisview_names.add_last(write_string(a_view.external_name))
	_endloop
	_self.status << :ok
	_self.changed(:status_string)

	>> gisview_names

_endmethod
$

_pragma(classify_level=restricted)
_method ghc_mapping_definator.changed_gisview(a_view_nr)
	##
	## Setzt die ausgewählte Schalvo in den Slot

	.dsview <<  .gisviews[a_view_nr]
	_self.update_mache_class_liste()
	_self.manage_visibility()
_endmethod
$

_method ghc_mapping_definator.show_messager(aspect)
	##
	_self.hide_messager()

	_local k << :ghc_waiting_messager

	dlg << _self.get_dialog(k)
	_if dlg _isnt _unset
	_then
		dlg.quit()
	_endif
	dlg << ghc_waiting_messager.open( .my_application,
					  .my_plugin,
					  _self.message(:please_wait),
					  _self.message(:git_mapdef_sortiere),
					  _self, 80)
	_self.cache_dialog(k,dlg)
_endmethod
$
_method ghc_mapping_definator.hide_messager()
	##
	_try
		_local k << :ghc_waiting_messager
		dlg << _self.get_dialog(k)
		_if dlg _isnt _unset
		_then
			dlg.quit()
		_endif

	_when error
	_endtry
_endmethod
$

_pragma(classify_level=restricted)
_method ghc_mapping_definator.update_mache_class_liste()
	## 
	## 
	.menu_items[:class_lister].items << _self.mache_class_liste
_endmethod
$


_pragma(classify_level=restricted)
_method ghc_mapping_definator.mache_class_liste
	##
	## Erzeugt die Liste der vorhandenen Klassen
	##
	_self.status << :busy
	#_self.changed(:status_busy)

	_if .dsview _is _unset
	_then
		_if .top_frame.active?
		_then
			_self.show_alert(_self.message(:no_view),_self.message(:ok))
		_endif
		_self.status << :ok
		_self.changed(:status_string)
		_return {}
	_endif

	_self.show_messager(:sorting)
	_local names << rope.new()
	_if .level = 0 _orif
	    .level = 1
	_then
		# Klassenliste hier erzeugen vom view
		.level << 1
		# .classes[ .level] << hash_table.new()
		.classes[ .level] << rope.new() #hash_table.new()

		# Erste Editierung -> Erzeuge Liste aus Tables des .dsviews
		_local classes_sorted << sorted_collection.new( _unset,
								_proc(e1, e2)
									_return e1.external_name _cf e2.external_name
								_endproc)
		_for coll _over .dsview.user_tables()
		_loop
			classes_sorted.add(coll)
		_endloop
		# .classes[ .level][ coll.external_name.as_symbol()] << coll
		_for coll _over classes_sorted.elements()
		_loop
			.classes[ .level].add_last(coll)#
			# .classes[ .level]   [ coll.name.as_symbol()] << coll
		_endloop
	_else
		# subclassen übernehmen

		_if .classes[ .level] _is _unset
		_then
			# .classes[ .level] << _self.childs_of( .selected_class_in_level[ .level - 1 ])
			.classes[ .level] << sorted_collection.new(_unset,
								   _proc(e1, e2)
									   _return e1.external_name _cf e2.external_name
								   _endproc

							       )
			.classes[ .level].add_all( _self.childs_of( .selected_class_in_level[ .level - 1 ]) )
		_endif

#		_self.changed(:mache_field_liste)
#		_self.changed(:mache_child_liste)
	_endif
	_self.update_mache_feld_liste()
	_self.update_mache_child_liste()

	_for coll _over .classes[ .level].elements()
	_loop
		l_ext_name << coll.external_name
		_for i _over range(l_ext_name.size, 25)
		_loop
			l_ext_name +<< " "
		_endloop
		names.add_last({write_string(l_ext_name,
					    tab_char,
					    "[",
					    coll.name,"]"), coll})
	_endloop

	_self.update_mache_feld_liste()

	.class_names << names # .as_sorted_collection()
	_self.status << :ok
	_self.changed(:status_string)


	_self.hide_messager()

	>> .class_names

_endmethod
$

_pragma(classify_level=restricted)
_method ghc_mapping_definator.changed_class(p_collection_vec)
	##
	l_coll << p_collection_vec.an_element()
	_if l_coll _is _unset
	_then
		_return
	_endif 
	# .selected_class_in_level[ .level] << .classes[ .level][ .class_names[a_view_nr].as_symbol()]
	.selected_class_in_level[ .level] << l_coll
	.menu_items[:class_name].label << write_string( "[",
							.dsview.external_name,
							"] ",
							l_coll.external_name)

	_self.update_mache_feld_liste()
	_self.update_mache_child_liste()
	_self.manage_visibility()

_endmethod
$

_pragma(classify_level=restricted)
_method ghc_mapping_definator.update_mache_child_liste()
	## 
	## 
	.menu_items_novis[:child_lister].items << _self.mache_child_liste
_endmethod
$


_pragma(classify_level=restricted)
_method ghc_mapping_definator.mache_child_liste
	##
	## Erzeugt die Liste
	##
	_self.status << :busy
	#_self.changed(:status_busy)

	_if .dsview _is _unset _orif
	    .selected_class_in_level[ .level] _is _unset
	_then
		_return {}
	_endif

	.child_classes_in_level[ .level] << _self.childs_of( .selected_class_in_level[ .level])
	.child_classes_names << rope.new()
	_if .child_classes_in_level[ .level] _is _unset
	_then
		_return {}
	_endif 
	l_coll_set << equality_set.new_from(.child_classes_in_level[ .level])
	l_sc << sorted_collection.new(l_coll_set.size)
	l_sc.sort_by(:external_name)
	l_sc.add_all(l_coll_set)
#	_for cl _over .child_classes_in_level[ .level].elements()
#	_loop
#		_if _not l_coll_vec.includes?(cl) #.child_classes_names.includes?(a_name << cl.external_name)
#		_then
#			.child_classes_names.add_last({a_name, cl)
#		_endif
#	_endloop
	_for i_coll _over l_sc.fast_elements()
	_loop
		.child_classes_names.add_last({i_coll.external_name, i_coll})
	_endloop 
	_self.status << :ok
	_self.changed(:status_string)
	>> .child_classes_names
_endmethod
$
_pragma(classify_level=restricted)
_method ghc_mapping_definator.childs_of(class)
	##
	## Ermittelt die an der Objektklasse hängenden Joins. und
	## liefert typ zurück.
	##
	_local child_classes << hash_table.new()
	_if .dsview _is _unset _orif
	    class _is _unset
	_then
		_return child_classes
	_endif

	# Hole Record Exemplar
	_if .dsview.collections[class.name] _is _unset
	_then
		_return
	_endif 
	descr << .dsview.collections[class.name].descriptor
	_for ajf _over descr.join_fields.elements()
	_loop
		# Füge childs nur für zu 1 joins hinzu
		# show( a_join[:type], a_join[:myowner], a_join[:child],write_string(a_join[:type]).matches?("*:1"))
		# Super Joins
		_local jt
	#	_try _with cond

			jt << ajf.ghc!relation_type
#		_when error
#			write("Problem in ghc_mapping_definator.childs_of(class)")
#			print(cond)
#			_continue
#		_endtry

		# Erlaubte Feldtypen...
		_if {:|1:1|,
		     :|1:0|,
		     :|0:1|,
		     :|N:1|,
		     :|N:0|}.includes?(jt)
		_then
			#hole join
			_local tcoll << ajf.ghc!target_collection
			child_classes[tcoll.external_name.as_symbol()] << tcoll
		_endif

	_endloop

	_local myownernamesymb
	_if .level - 1 > 0
	_then
		myownernamesymb <<  .selected_class_in_level[ .level - 1].external_name.as_symbol()
	_endif

	# Remove the myowner Object Class Name to be sure that the
	# people can´t go back the same join
	_if child_classes[myownernamesymb] _isnt _unset
	_then
		child_classes.remove_key(myownernamesymb)
	_endif

	>> child_classes
_endmethod
$

_pragma(classify_level=restricted)
_method ghc_mapping_definator.toggle_item_visibility(item)
	##
	.menu_items[item].visibility << _not .menu_items[item].visibility
_endmethod
$

_pragma(classify_level=restricted)
_method ghc_mapping_definator.level_down
	##
	_if .dsview _is _unset
	_then
		_self.show_alert(_self.message(:no_view),_self.message(:ok))
		_return _false
	_elif .selected_class_in_level[ .level] _is _unset
	_then
		_self.show_alert(_self.message(:no_class_selected),_self.message(:ok))
		_return _false
	_endif
	.used_classes_in_level[ .level][ .selected_class_in_level[ .level].name.as_symbol()] << .selected_class_in_level[ .level]

	_self.leaving_level

	.level +<< 1
	_self.action(:view).enabled? << .level = 1
	.classes[ .level] << _unset

	_self.entering_level

_endmethod
$

_pragma(classify_level=restricted)
_method ghc_mapping_definator.level_up
	##
	## gehe in obere ebene
	##
	_self.leaving_level
	_if ( .level -<< 1) < 1 _then .level << 1 _endif
	_self.action(:view).enabled? << .level = 1
	_self.entering_level
_endmethod
$
_pragma(classify_level=restricted)
_method ghc_mapping_definator.actualize_myowners
	##
	l_sel_class << .selected_class_in_level[ .level]
	_if l_sel_class _isnt _unset
	_then
		.menu_items[:class_lister].selected_items << {l_sel_class}
	_endif

	_local tc
	_if .level _isnt 1
	_then
		.menu_items[:myowner_class_names].label << write_string("[", .dsview.external_name,"] ",
								       (tc << .selected_class_in_level[ .level - 1 ]).external_name,
								       " (",_self.message(:level)," ", .level-1,")",newline_char ,
								       _self.message(:internal_name), " ",tc.name)
	_else
		.menu_items[:myowner_class_names].label << ""
	_endif

_endmethod
$
_pragma(classify_level=restricted)
_method ghc_mapping_definator.entering_level
	##
	## Liefert den Wert für die collection Anzeige
	##
	_self.update_mache_class_liste()
	_self.actualize_myowners
	_self.manage_visibility()
_endmethod
$
_pragma(classify_level=restricted)
_method ghc_mapping_definator.leaving_level
	##
	## Liefert den Wert für die collection Anzeige

_endmethod
$

_pragma(classify_level=restricted)
_method ghc_mapping_definator.menus
	##
	## Menudefinition
	##
# OLD:
#	_local ls << _super(ghc_menu_basis).menus
# END
# NEW:
	_local ls << _super.menus
# END

	ls[:menubar] << {:menubar, :actions , :navigation, :edit, :database_action}#, :help}

	ls[:actions] << {:submenu, :apply, :seperator, :reset, :separator}  #, :quit}

	ls[:navigation] << {:submenu, :level_up, :level_down}

	ls[:edit] << {:submenu,
		      :add_field_mapping,
		      :shorten_fieldname}#,
#		      :separator,
#		      :add,
#		      :remove,
#		      :remove_all}

	ls[:database_action] << {:submenu, :transfer_to_db}

	_return ls

_endmethod
$

#_pragma(classify_level=restricted)
#_method ghc_mapping_definator.functions
#	##
#	## Define the standard buttons that could be included onto the menubar
#
## OLD:
##	_local ls << _super(ghc_menu_basis).functions
## END
## NEW:
#	_local ls << _super.functions
## END
#
#	ls[:apply]                << {:button, :action, :apply|()|}
##	ls[:quit]                 << {:button, :action, :quit|()|}
#	ls[:level_up]             << {:button, :action, :level_up}
#	ls[:level_down]           << {:button, :action, :level_down}
#	ls[:add_field_mapping]    << {:button, :action, :add_field_mapping|()|}
#	ls[:shorten_fieldname]    << {:button, :action, :add_field_mapping|()|}
#	ls[:reset]                << {:button, :action, :reset|()|  }
#
#	_return ls
#
#_endmethod
#$

_pragma(classify_level=restricted)
_method ghc_mapping_definator.update_mache_feld_liste()
	## 
	## 
	.menu_items[:field_lister].items << _self.mache_feld_liste
_endmethod
$


_pragma(classify_level=restricted)
_method ghc_mapping_definator.mache_feld_liste
	##
	## Erzeugt feldliste
	##
	_self.status << :busy
	_self.changed(:status_string)
	.selected_field << _unset

	_if .dsview _is _unset _orif
	    .selected_class_in_level[ .level] _is _unset
	_then
		_self.status << :ok
		_self.changed(:status_string)
		_return {}
	_endif

	.actual_fields << hash_table.new()
	.actual_fields[:git!names] << rope.new()
	.actual_fields[:git!types] << hash_table.new()

	_for i _over (my_class << .selected_class_in_level[ .level]).all_fields.elements()
	_loop @allefelder
		# show(i.name, i.type.class_name)
		# Erlaubte Felder

		_if ( ( {:dd_geom_field,
			 :dd_phys_field}.includes?(i.class_name)) _orif
		      ( {:dd_derived_field}.includes?(i.class_name) _and
			my_class.visible_fields.includes?(i))) _andif
		    _not i.name.matches?("*!*") _andif
		    _not {:rwo_id, :text_id, :ds!version, :meatball}.includes?(i.name)
		_then
			l_field_type << _unset
			# Änderung Schlüsselfelder checken
			_if my_class.key_fields.includes?(i)
			_then
				l_field_type << " * Key"
			#	ename << write_string("*[Key]", tab_char, i.external_name)
			_elif _not my_class.visible_fields.includes?(i)
			_then
				_if .menu_items[:visible_fields_only].value
				_then
					_continue @allefelder
				_else
					l_field_type << "Verst"
				_endif
			_elif i.class_name _is :dd_geom_field
			_then
				l_field_type << "Geom"
			_elif i.class_name _is :dd_derived_field
			_then
				l_field_type << "Log"
			_endif
			ename << _self.get_ename_for(i, l_field_type)
#			_else
#				l_space_char << ""
#				_for i_numb _over range(i.external_name.size, 14)
#				_loop
#					l_space_char +<< " "
#				_endloop
#
#				ename << write_string(tab_char, i.external_name, l_space_char, tab_char, i.name)
#			_endif
#			_if _not my_class.visible_fields.includes?(i)
#			_then
#				_if .menu_items[:visible_fields_only].value
#				_then
#					_continue @allefelder
#				_else
#					ename << write_string("[Versteckt]", tab_char, i.external_name)
#				_endif
#			_endif
#
#			_if i.class_name _is :dd_geom_field
#			_then
#				ename << write_string("[Geometrie]", tab_char, ename)
#			_elif i.class_name _is :dd_derived_field
#			_then
#				ename << write_string("[Logisch]", tab_char, ename)
#			_endif

			.actual_fields[:git!names].add_last(ename) #i.external_name)
			.actual_fields[ename.as_symbol()] << i.name
			.actual_fields[:git!types][ename.as_symbol()] << i.class_name
		_endif
	_endloop

	# nun noch die Text Joinfelder...
	_for jf _over my_class.join_fields.elements()
	_loop

		_if jf.join_type _is :text
		_then
			l_field_type << write_string("Text")
			ename << _self.get_ename_for(jf, l_field_type)
		#	ename << write_string("[Text]", tab_char, jf.external_name)
			.actual_fields[:git!names].add_last(ename) #i.external_name)
			.actual_fields[ename.as_symbol()] << jf.name
			.actual_fields[:git!types][ename.as_symbol()] << jf.class_name
		_endif
		_if jf.join_type _is :follow _andif
		    jf.ghc!relation_type _isnt :internal
		_then

			l_field_type << write_string("Verkn")
			ename << _self.get_ename_for(jf, l_field_type)

	#		ename << write_string("[Verkn ", jf.ghc!relation_type, "]", tab_char, jf.external_name)

			.actual_fields[:git!names].add_last(ename) #i.external_name)
			.actual_fields[ename.as_symbol()] << jf.name
			.actual_fields[:git!types][ename.as_symbol()] << jf.class_name
		_endif

	_endloop

	_self.status << :ok
	_self.changed(:status_string)

	>> ( .actual_fields[:git!names] << .actual_fields[:git!names].as_sorted_collection())

_endmethod
$

_pragma(classify_level=restricted)
_method ghc_mapping_definator.get_ename_for(p_field, p_field_type)
	##
	l_ename << ""

	_if p_field_type _isnt _unset
	_then
		l_ename +<< p_field_type
	_else
		l_ename +<< " |  "
	_endif
	l_ename +<< tab_char
	l_space_char << ""
	_for i_numb _over range(p_field.external_name.size, 14)
	_loop
		l_space_char +<< " "
	_endloop
	l_ename +<< write_string(p_field.external_name, l_space_char, tab_char, p_field.name)
	_return l_ename
_endmethod
$

_pragma(classify_level=restricted)
_method ghc_mapping_definator.changed_field(p_field_vec)
	##
	## Wählt Feld aus
	##
	_local name << p_field_vec.an_element()
	.selected_field << .actual_fields[ name.as_symbol()]

	# Prüfe ob Geometriefeld
	_if .actual_fields[:git!types][name.as_symbol()] _is :dd_geom_field
	_then
		.geofield_selected? << _true
	_else
		.geofield_selected? << _false
	_endif

	# Add Class to selected classes in level
	.used_classes_in_level[ .level][ .selected_class_in_level[ .level].name.as_symbol()] << .selected_class_in_level[ .level]

	# Only print internal_field in Zuordnung, when no
	# mapped_external_fields exist (export)
	_if _not _self.is_import?
	_then
		.menu_items[:map_to_field_name].value << write_string( .actual_fields[ write_string(name).as_symbol()])
	_endif
	_self.manage_visibility()
_endmethod
$

_pragma(classify_level=restricted)
_method ghc_mapping_definator.is_import?
	##
	_if .external_field_names_to_map _is _unset _orif
	    .external_field_names_to_map.size = 0
	_then
		_return _false
	_else
		_return _true
	_endif
_endmethod
$

_pragma(classify_level=restricted)
_method ghc_mapping_definator.update_mache_externe_feld_liste()
	## 
	##
	_if .menu_items[:external_field_lister] _isnt _unset
	_then 
		.menu_items[:external_field_lister].items << _self.mache_externe_feld_liste
	_endif 
_endmethod
$

_pragma(classify_level=restricted)
_method ghc_mapping_definator.update_mache_mapping_liste()
	## 
	## 
	_if .menu_items[:mapping_list] _isnt _unset
	_then 
		.menu_items[:mapping_list].items << _self.mache_mapping_liste
	_endif 
_endmethod
$

_pragma(classify_level=restricted)
_method ghc_mapping_definator.mache_externe_feld_liste
	##
	## Erzeugt feldliste

	_self.status << :busy
	_self.changed(:status_string)

	# Erzeuge rope mit den Felddefinitionen
	.external_field_names_to_map << rope.new_from( .external_field_names_to_map )

	_local feldnamen << rope.new()
	_for fd _over .external_field_names_to_map.fast_elements()
	_loop

		name << fd.description

		feldnamen.add_last({name, fd})
	_endloop

	_return  feldnamen

_endmethod
$

_pragma(classify_level=restricted)
_method ghc_mapping_definator.changed_external_field(p_field_vec)
	##
	## Wählt Feld aus
	##
	l_field << p_field_vec.an_element()
	feldname << l_field.name
	.menu_items[:map_to_field_name].value << write_string(feldname)
	_self.manage_visibility()

_endmethod
$

_pragma(classify_level=restricted)
_method ghc_mapping_definator.apply()
	##
	_return 
_endmethod
$

_pragma(classify_level=restricted)
_method ghc_mapping_definator.add_field_mapping()
	##
	## Erzeugt neues Mapping und erzeugt zugehörige Objekte
	##
	_local extname << write_string( .menu_items[:map_to_field_name].value)
	_if .selected_field _is _unset
	_then
		_self.show_alert(_self.message(:no_field),_self.message(:ok))
		_return
	_endif
	_if .level > 1
	_then
		_if (myownermap << _self.search_mapping_or_submapping( .selected_class_in_level[ .level - 1 ].name.as_symbol())) _is _unset
		_then
			condition.raise(:myowner_mapping_unset)
			_return 
		_endif
	_endif
	the_mapping << _self.search_mapping_or_submapping(cn_symb << .selected_class_in_level[ .level].name.as_symbol())
	
	# Prüfe Anzahl der Geometriefelder und lasse Zuordnung nur, zu
	# Wenn Maximale Anzahl nicht überschriten ist....
	_if .geofield_selected?
	_then
		_local number_geofields << 0
		_if myownermap _isnt _unset
		_then
			number_geofields << myownermap.number_geofields_in_tree
		_elif the_mapping _isnt _unset
		_then
			number_geofields << the_mapping.number_geofields_in_tree
		_endif
		
		_if number_geofields >= _self.max_geometry_fields
		_then
			_self.show_alert(_self.message(:max_number_of_geometry_fields_already_selected!,_self.max_geometry_fields),
					 _self.message(:ok))
			_return 
		_endif
	_endif
	_if the_mapping _is _unset
	_then
		the_mapping << record_transaction.new_insert(.mapcoll,
							     property_list.new_with(
								     :view_name, _self.action(:view).value,
								     :database_classname,
								     .selected_class_in_level[ .level].name)).run()
	
	_endif
	
	_if myownermap _isnt _unset
	_then
		the_mapping.myowner_of_childs << myownermap
	_endif
	
	# Füge ein in Hash Class_mappings wenn, level 1 ist
	_if the_mapping.level = 1
	_then
		the_mapping.git_transfers <<  set.new_from( { .transfer_object})
		.class_mappings[ the_mapping.database_classname.as_symbol()] << the_mapping
	_endif
	
	_if _not .external_field_names.includes?(extname.as_symbol())
	_then
		
		# Suche childmapping
		_local newfmap << _false
		_local fmaps << the_mapping.git_field_mappings
		l_field_mapping <<  fmaps.select(predicate.eq(:internal_fieldname,  write_string( .selected_field ))).an_element()
		
		l_prop << property_list.new_with(
				  :database_classname, the_mapping.database_classname,
				  :internal_fieldname, write_string( .selected_field ),
				  :external_fieldname, write_string(extname),
				  :git_mapping_id, the_mapping.id)
		_if l_field_mapping _is _unset
		_then
			fmap << record_transaction.new_insert(.fmapcoll,
							      l_prop).run()
		_else
			_self.add_name_to_external_field_list(l_field_mapping.external_fieldname.write_string)
			fmap << record_transaction.new_update(l_field_mapping,
							      l_prop).run()
		_endif 
		
		.external_field_names.add_last(extname.as_symbol())
		
		# Entferne externen Feldnames aus zu mappenden Feldnamen
		_self.remove_name_from_fields_to_map(extname)
		.menu_items[:map_to_field_name].value << _unset
		_self.changed(:mache_externe_feld_liste)
		
	_else
		_self.show_alert(_self.message(:external_fieldname_already_exists),_self.message(:ok))
	_endif

	_self.update_mache_mapping_liste()

_endmethod
$

_method ghc_mapping_definator.remove_name_from_fields_to_map(extname)
	##
	## Entfernt Feldnamen aus lister der zumappenden felder

	_local new_list << rope.new()
	_for i _over .external_field_names_to_map.fast_elements()
	_loop

		_if _not (i.name.as_symbol() = extname.as_symbol())
		_then
			new_list.add_last(i)
		_endif
	_endloop
	.external_field_names_to_map << new_list.as_sorted_collection()

_endmethod
$

_pragma(classify_level=restricted)
_method ghc_mapping_definator.add_name_to_external_field_list(p_extname)
	##
	## Adds external field name to List: zu mappende externe Felder

	l_all_ext_field_vec << .all_external_field_names_to_map

	_for i_ext_field _over l_all_ext_field_vec.fast_elements()
	_loop @searcher

		_if i_ext_field.name = p_extname
		_then
			l_wanted_ext_field << i_ext_field
			_leave
		_endif
	_endloop
	.external_field_names.remove(p_extname.as_symbol())

	_if l_wanted_ext_field _isnt _unset
	_then

		.external_field_names_to_map.add(l_wanted_ext_field)

		_self.update_mache_externe_feld_liste()
	_endif
_endmethod
$

_pragma(classify_level=restricted)
_method ghc_mapping_definator.search_mapping_or_submapping(classname)
	##
	_local the_mapping
	_if .class_mappings.keys.includes?( classname) _andif .level = 1
	_then
		the_mapping << .class_mappings[classname]
	_else
		_for cm _over .class_mappings.elements()
		_loop @loopy
			the_mapping << cm.return_submapping(classname)
			_leave @loopy
		_endloop
	_endif

	_return the_mapping

_endmethod
$

_pragma(classify_level=restricted)
_method ghc_mapping_definator.mache_mapping_liste
	##
	## Erzeugt angezeigte Liste der Mapping im Mapping Listview
	##
	_self.status << :busy
	_self.changed(:status_string)

	.transfer_object << .mapping_dsview.collections[:git_transfer].at( .transfer_id)
	_self.update_class_mappings

	.objectlist << rope.new()

	_if .class_mappings.empty?
	_then
		_self.status << :ok
		_self.changed(:status_string)
		_local l_none_text << _self.message(:none)

		_return {l_none_text}
	_endif

	# Erzeugt Mapping Liste für die Ansicht
	_local maplist << rope.new()
	_for i _over .class_mappings.elements()
	_loop
		
		(mappinglist, mappingobjects) <<  i.list_mapping_structure(1)
		_for i _over range(1, mappinglist.size)
		_loop
		
			maplist.add( {mappinglist[i], mappingobjects[i] } )
			.objectlist.add(mappingobjects[i])
		_endloop 
	_endloop

	_self.status << :ok
	_self.changed(:status_string)

	_return maplist
_endmethod
$

_pragma(classify_level=restricted)
_method ghc_mapping_definator.shorten_fieldname()
	##
	## Shorten Fieldname to 8 Characters
	##
	_local name << write_string( .menu_items[:map_to_field_name].value)#.copy()
	.menu_items[:map_to_field_name].value << _self.crop_to_digits( .external_field_names, name, 8, 6)

_endmethod
$

_pragma(classify_level=restricted)
_method ghc_mapping_definator.crop_to_digits(shortnames, original_name, _optional maxchars, maxdigits)
	##
	_local renamevec << rope.new()
	_local newfieldsvec << rope.new()
	_local renamed << rope.new()
	_local a_name
	_local shortname

	_if maxdigits _is _unset
	_then
		maxdigits << 7
	_endif             # max anzahl schriftzeichen
	_if maxchars _is _unset
	_then
		maxchars << 10
	_endif             # max anzahl schriftzeichen

	# start renaming now
	_local truncated_name << ""

	# Erste 7 zeichen in kurzbez
	_local max_number_digits    # max zahl der numerischen zeichen

	_if original_name.size <= maxdigits
	_then
		maxcount << original_name.size
	_else
		maxcount << maxdigits
	_endif

	max_number_digits << maxchars - maxcount

	_for b _over range(1,maxcount)
	_loop
		truncated_name +<< original_name[b]
	_endloop

	# Bestimme den maximalen Zaehler
	_local maxrange << 9
	_for i _over range(1,max_number_digits - 1)
	_loop
		maxrange << (maxrange * 10) + 9
	_endloop

	_for a_count _over range(0,maxrange)
	_loop @inner
		stellen << write_string(a_count).size

		_local a_count_string << ""

		_for sdfi _over range(1,max_number_digits - stellen)
		_loop
			a_count_string << write_string(a_count_string,"0")
		_endloop

		a_count_string << write_string(a_count_string, a_count)
		shortname << write_string(truncated_name,a_count_string).as_symbol()

		_if _not shortnames.includes?(shortname)
		_then
			_return shortname
		_endif
	_endloop

	_return _unset

_endmethod
$

_pragma(classify_level=restricted)
_method ghc_mapping_definator.actual_transfer_name
	##
	## Field Mapping Popup Menudefinition
	##
	_return write_string( .actual_transfer_name )

_endmethod
$

_pragma(classify_level=restricted)
_method ghc_mapping_definator.fill_slots_with_loaded_data
	##
	## fill_slots_with_loaded_data
	##

	.external_field_names << rope.new()
	_for i _over .class_mappings.elements()
	_loop

		.external_field_names.add_all_last( i.all_subext_names )
	_endloop

	# checke ob zu mappende externe feldnamen schon gemappt sind....
	_for i _over .external_field_names.elements()
	_loop
		_self.remove_name_from_fields_to_map(i)
	_endloop
	_self.update_mache_externe_feld_liste()
_endmethod
$

_pragma(classify_level=restricted)
_method ghc_mapping_definator.note_change(who_changed, aspect, _optional change_info, _gather more_change_info)
	##
	## Note change ...
	##
	_super.note_change(who_changed, aspect, change_info, more_change_info)
	#  show(who_changed, aspect, change_info, more_change_info)

	_if who_changed _is _self
	_then
#		_if aspect _is :status_string
#		_then
#			_if _self.status _is :ok
#			_then
#				_self.switch_visibility(_true)
#			_elif _self.status _is :busy
#			_then
#				_self.switch_visibility(_false)
#			_endif
#		_endif
	_endif

	_if .sub_menus.includes?(who_changed)
	_then

		_if {:update,:insert, :delete}.includes?(aspect)
		_then
			_self.manage_visibility()
			# _self.reset
			# _self.update_class_mappings
			 _self.update_mache_mapping_liste()
			 _self.update_class_mappings

		_endif
	_endif

_endmethod
$
_pragma(classify_level=restricted)
_method ghc_mapping_definator.switch_visibility(how?)

	_if _not {_true,_false}.includes?(how?)
	_then
		_leave
	_endif

	_for k,e _over .menu_items.keys_and_elements()
	_loop
		_if e.responds_to?(:visibility)
		_then
			e.visibility << how?
		_endif
	_endloop

_endmethod
$

#_pragma(classify_level = basic, topic={GIT})
#_method ghc_mapping_definator.on_activation()
#	##
#	_super(ghc_menu_basis).on_activation()
#	_super(wizard_base).on_activation()
#	_self.status << :ok
#	_self.changed(:status_string)
#_endmethod
#$
#
_pragma(classify_level=restricted)
_method ghc_mapping_definator.finish()

	_self.changed(:finished)
	_self.close()
	_super.quit()
_endmethod
$

_method ghc_mapping_definator.manage_visibility()

	l_has_value? <<  _not (.menu_items[:map_to_field_name].value _is _unset _orif
			      .menu_items[:map_to_field_name].value.trim_spaces() = "")

	.menu_items[:shorten].visibility << l_has_value? _andif
					    _self.is_import? _is _false
	.menu_items[:add_field_mapping].visibility << l_has_value?

	l_level << .level.default(1)
	.menu_items[:upbutton].visibility << l_level > 1
	.menu_items[:downbutton].visibility << .selected_class_in_level[ .level] _isnt _unset
_endmethod
$

_pragma(classify_level=restricted)
_method ghc_mapping_definator.view_changed(p_view_name)
	## 
	##
	.dsview << gis_program_manager.databases[p_view_name]
	_self.update_collection()
_endmethod
$

_pragma(classify_level=restricted)
_method ghc_mapping_definator.update_collection()
	## 
	##
	_self.update_mache_class_liste()
#	.menu_items[:class_lister]
_endmethod
$

