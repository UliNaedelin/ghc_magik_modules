#% text_encoding = iso8859_1
_package user


def_slotted_exemplar(:ghc_http_command_service,
{
	{:execution_thread, _unset}
},
{:mss_http_service})
$

_pragma(classify_level=debug, topic={mss_common})
_method ghc_http_command_service.process_service_request(req)
	## 
	## Respond to the request by reporting back the current time,
	## along with URL information.
	##

	_dynamic !ghc_json_max_collection_query_depth!
	_dynamic !ghc_json_max_records!
	.request << req
	resp << req.response

	_if req.http_request_method ~= "POST"
	_then
		resp.set_header_field("Cache-Control", "private,max-age=0")
		resp.set_header_field("Content-Type", "text/html")
		resp.set_header_field("Connection", "Close")
		resp.set_status_code(500)
		_self.server.send_request_response(req)
	
		_return 
	_endif

	l_json_string << _self.request_body

	(l_application,
	 l_real_object,
	 l_method,
	 l_par_vec,
	 l_dynamic_variables,
	 l_json_stream_as_parameter?
	) << _self.process_request_json_string(l_json_string)
	
	_if l_dynamic_variables _isnt _unset
	_then
		_for i_var _over l_dynamic_variables.fast_elements()
		_loop
			_thisthread.dynamic_value(package(:user).global_at(i_var.name.as_symbol())) << i_var.value
		_endloop 
	_endif 

	l_stream << internal_text_output_stream.new()
	
	_if l_real_object _isnt _unset
	_then
		_if l_json_stream_as_parameter?
		_then		
		
			resp.set_header_field("Cache-Control", "private,max-age=0")
			resp.set_header_field("Content-Type", "application/json")
			resp.set_header_field("Connection", "Close")
			resp.set_status_code(200)
			l_stream << req.connection.output
			resp.write_header_on(l_stream)
			l_text_stream << ghc_text_binary_input_stream.new(l_stream)
			l_par_vec.add_first(l_text_stream)
			
			l_real_object.perform(l_method.as_symbol(), _scatter l_par_vec)
			l_stream.flush()
			_if (resp << req.response) _isnt _unset
			_then
				st << resp.status_line()
			_else
				st << _self.server.message(:unknown_status)
			_endif
			_self.server.write_log(4, req.connection_manager, _self.server.message(:log_response_sent, st))
			_return 
			
		_else 
			l_res_vec << _allresults l_real_object.perform(l_method.as_symbol(), _scatter l_par_vec)
		_endif 
		
	_elif l_method _isnt _unset
	_then
		l_proc << !current_package![l_method.as_symbol()]
		_if l_proc _isnt _unset _andif
		    l_proc.class_name _is :procedure
		_then
			l_res_vec << _allresults l_proc.invoke( _scatter l_par_vec)
			
		_endif 
	_endif
	_if l_res_vec _isnt _unset
	_then 
		
		l_res_vec.ghc!write_as_json(l_stream)
	_endif
	_if l_stream _isnt _unset
	_then 	
		l_string << l_stream.string
	_endif 
	
	resp.set_header_field("Cache-Control", "private,max-age=0")
	resp.set_header_field("Content-Type", "application/json")
	resp.set_header_field("Connection", "Close")
	resp.set_status_code(200)
	_if l_string _isnt _unset
	_then
		
		resp.response_object << l_string
	_else
		l_object << ghc!json_object.new()
		l_object.response << "No response"
		resp.response_object << l_object.write_string
	_endif 
	

	# Finally, ask the server to send this request.

	_self.server.send_request_response(req)


_endmethod
$

_pragma(classify_level=debug, topic={mss_common})
_method ghc_http_command_service.stream_as_parameter_method(p_method)
	## 
	## 
	_if p_method.write_string.last _is %)
	_then
		p_method << p_method.write_string.slice(1, p_method.size -2)
	_endif
	_return (p_method.write_string + "_with_stream?").as_symbol()
_endmethod
$


_pragma(classify_level=debug, topic={mss_common})
_method ghc_http_command_service.process_request_json_string(p_json_string)
	## 
	## 
	l_json_object << ghc!json_parser.parse_string(p_json_string)
	l_json_stream_as_parameter? << _false 
	l_object << l_json_object.object
	l_method << l_json_object.method
	l_application << l_json_object.application
	l_parameter_vec << l_json_object.params
	l_dynamic_variables << l_json_object.dynamic_variables
	_if l_object _isnt _unset
	_then
		l_object << l_object.as_symbol()
	_endif 
	_if l_application _isnt _unset _andif
	    l_application ~= ""
	_then
		l_application << l_application.as_symbol()
		_if l_application = :first_found
		_then
			_for i_app _over smallworld_product.applications.fast_elements()
			_loop
				_if i_app.plugin(l_object) _isnt _unset
				_then
					l_app << i_app
					_leave
				_endif 
			_endloop
		_else
			l_app << smallworld_product.application(l_application)
			_if l_app _is _unset
			_then
				l_default_app_name << l_application
			_endif 
		_endif 
		_if l_app _is _unset
		_then
			_if l_default_app_name _is _unset
			_then
				l_default_app_name << _self.default_app_name
			_endif
			l_app_def << smallworld_product.application_definition(l_default_app_name)
			_if l_app_def _isnt _unset
			_then 
				l_app << l_app_def.int!start()
			_endif 
		_endif
		_if l_app _isnt _unset
		_then 
			l_real_object << l_app.plugin(l_object)
		_endif 	
	_endif
	
	_if l_real_object _is _unset _andif
	    l_object _isnt _unset
	_then 
		l_real_object << !current_package![l_object]
	_endif

	_if l_parameter_vec _isnt _unset
	_then		
		l_par_vec << rope.new_from(l_parameter_vec)
	_else
		l_par_vec << rope.new()
	_endif
	l_stream_method << _self.stream_as_parameter_method(l_method)
	_if l_real_object _isnt _unset
	_then
		_if l_real_object.responds_to?(l_stream_method) _andif
		    l_real_object.perform(l_stream_method) _is _true
		_then
			l_json_stream_as_parameter? << _true 
		_endif
	_else
		_if (l_proc << !current_package![l_stream_method]) _isnt _unset _andif
		    l_proc.invoke() _is _true
		_then
			l_json_stream_as_parameter? << _true 
		_endif 		
	_endif
	_return l_application, l_real_object, l_method, l_par_vec, l_dynamic_variables, l_json_stream_as_parameter?
_endmethod
$



_pragma(classify_level=debug, topic={mss_common})
ghc_http_command_service.define_shared_constant(
	:default_app_name,
	:nrmb_swaf_application,
	:public)
$
